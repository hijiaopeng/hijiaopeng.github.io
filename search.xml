<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux7.4快速搭建WordPress博客</title>
    <url>/2021/02/24/Linux-WordPress/</url>
    <content><![CDATA[<p>这篇博客是我几年前写的了，当初买的阿里云服务器，又正巧学习了一段时间Linux，才搞的WordPress。整体安装步骤应该一致，可能存在部分版本老旧问题。</p>
<span id="more"></span>

<h5 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h5><p>服务器：阿里云ECS Centos 7.4</p>
<p>系统架构：LAMP（Linux，Apache，MySQL，PHP）</p>
<p>博客框架：WordPress</p>
<h5 id="更新服务器"><a href="#更新服务器" class="headerlink" title="更新服务器"></a>更新服务器</h5><p>首先，我们需要确保服务器系统中的所有内容都是最新的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y update </span><br></pre></td></tr></table></figure>

<h5 id="搭建LAMP："><a href="#搭建LAMP：" class="headerlink" title="搭建LAMP："></a>搭建LAMP：</h5><p>安装Apache：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install httpd</span><br></pre></td></tr></table></figure>

<p>设置开机启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chkconfig httpd on</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start httpd.service</span><br></pre></td></tr></table></figure>

<p>查看服务状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status httpd.service </span><br></pre></td></tr></table></figure>

<p>配置云服务器安全组规则，设置Apache Http端口，一般为80。</p>
<p>规则方向为入方向，端口范围设置为80&#x2F;80，授权对象为0.0.0.0&#x2F;0。</p>
<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>先安装带有当前可用的mysql5系列社区版资源的rpm包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>查看当前可用的mysql安装资源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum repolist enabled | grep <span class="string">&quot;mysql.-community.&quot;</span> </span><br></pre></td></tr></table></figure>

<p>安装MySQL5.6版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install mysql-community-server </span><br></pre></td></tr></table></figure>

<p>设置MySQL开机启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> mysqld </span><br></pre></td></tr></table></figure>

<p>启动MySQL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start mysqld </span><br></pre></td></tr></table></figure>

<p>初始化MySQL各项配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>首次打开MySQL提示输入密码，默认是没有密码的，直接回车就可以。</p>
<p>其次开始设置MySQL各项配置：</p>
<p>mysqlsecureinstallation Set root password? [Y&#x2F;n] &#x2F;&#x2F;设置root密码（最好自己设置密码，选Y）</p>
<p>anonymous users? [Y&#x2F;n] &#x2F;&#x2F;删除匿名用户（选Y） </p>
<p>Disallow root login remotely? [Y&#x2F;n] &#x2F;&#x2F;禁止root用户远程登录（选n） </p>
<p>Remove test database and access to it? [Y&#x2F;n] &#x2F;&#x2F;删除默认的 test 数据库（选Y） </p>
<p>Reload privilege tables now? [Y&#x2F;n] &#x2F;&#x2F;是否马上应用最新的设置（选Y）</p>
<h5 id="创建WordPress数据库"><a href="#创建WordPress数据库" class="headerlink" title="创建WordPress数据库"></a>创建WordPress数据库</h5><p>登录MySQL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>输入之前设置的密码 创建WordPress需要的数据库，名称自定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create database wordpress;</span><br></pre></td></tr></table></figure>

<h5 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h5><p>安装PHP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install php php-mysql php-gd php-xml</span><br></pre></td></tr></table></figure>

<p>查看PHP版本，是否已经安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php -v</span><br></pre></td></tr></table></figure>

<h5 id="安装WordPress"><a href="#安装WordPress" class="headerlink" title="安装WordPress"></a>安装WordPress</h5><p>进入官网<a href="https://cn.wordpress.org/txt-download/">WordPress下载地址</a>，查看最新版本号，并进行下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://cn.wordpress.org/wordpress-最新的版本号-zh_CN.zip</span><br></pre></td></tr></table></figure>

<p>解压下载的压缩包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ unzip wordpress-最新的版本号-zh_CN.zip</span><br></pre></td></tr></table></figure>

<p>如果没有unzip的话，执行以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install unzip</span><br></pre></td></tr></table></figure>

<p>将wordpress下的所有文件复制到Apache服务器下的根目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -r wordpress/* /var/www/html/</span><br></pre></td></tr></table></figure>

<p>配置WordPress的配置文件</p>
<p>进入Apache的根目录html目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/www/html/</span><br></pre></td></tr></table></figure>

<p>复制配置文件到wp-config.php：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> wp-config-sample.php wp-config.php</span><br></pre></td></tr></table></figure>

<p>编辑WordPress的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi wp-config.php</span><br></pre></td></tr></table></figure>

<p>根据文件中的提示，依次设置数据库名称DB_NAME；</p>
<p>数据库用户名DB_USER（我这里使用的是root）；</p>
<p>数据库密码DB_PASSEWORD；</p>
<p>主机地址，默认为localhost，（也可以设置为服务器的IP地址），一般不需 要修改。</p>
<p>最后在文件末尾添加：</p>
<p>define(“FS_METHOD”, “direct”); define(“FSCHMODDIR”, 0777); define(“FSCHMODFILE”, 0777);</p>
<p>用来解决FTP登录凭据问题。</p>
<p>为了防止之后可能会出现的安装失败或者权限不足等问题， 后退找到html目录，给予它足够的权限，777，并且较为安全。（在安装和更新时设置为777，其他时候最好不要给与这么高权限，存在安全问题）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> -R 777 html/</span><br></pre></td></tr></table></figure>

<p>最后重启Apache服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart httpd.service</span><br></pre></td></tr></table></figure>

<h5 id="WordPress五分钟安装程序"><a href="#WordPress五分钟安装程序" class="headerlink" title="WordPress五分钟安装程序"></a>WordPress五分钟安装程序</h5><p>最后就是按照步骤，填写自己的站点信息和用户信息，一步一步填写就行，密码最好设置的较为复杂一些。之后会进入博客的仪表盘页面，可以在里面管理自己的网站了。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title>Elden Ring-速刷卢恩699大法</title>
    <url>/2022/05/16/ER-699/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>艾尔登法环里面，除了在“鲜血银行”刷乌鸦和白金之子，更为快捷的方式便是“699大法”了。</p>
<p>因为“王之卢恩”只能持有699个，所以叫做“699大法”。“王之卢恩”是最多的，一个5w。</p>
<p>这种刷卢恩的方式，有个很重要的前提，就是你得有一个同样在玩艾尔登法环的小伙伴，两个人一起刷。以下为操作步骤。图片在以后上传，现阶段为文字讲述。</p>
<span id="more"></span>

<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ul>
<li>两个同时在线的玩家A和B（确保服务器连接正常）</li>
<li>确保玩家A拥有“王之卢恩”。</li>
<li>玩家A打开电脑的C盘，找到文件夹的选项，打开后，点击“查看”，下滑找到“显示隐藏的文件、文件夹和驱动器”选项，并选中，依次点击“应用”–“确定”。</li>
<li>这时候，玩家A进入C盘–用户–用户名下，可以看见AppData文件夹了。</li>
<li>玩家A进入文件夹：C:\Users\用户名\AppData\Roaming\EldenRing\765……396（这里是一堆数字的文件夹），可以看到有3个文件：ER0000.sl2，ER0000.sl2.bak，steam_autocloud.vdf。</li>
<li>玩家A将ER0000.sl2复制出来，个人建议复制到桌面，这样好找。</li>
<li>此时准备工作基本完成。</li>
<li>玩家A和玩家B同时上线，找一个赐福点，两人同时传送过去。</li>
<li>两名玩家打开游戏页面的菜单，找到“多人联机游玩”，设置同一个“多人联机游玩暗号”，并确保应用成功。</li>
<li>玩家B使用“斗士勾指”画下红色符号，等待召唤。</li>
<li>玩家A在玩家B画完符号后，使用“唤勾指药”，就能看见玩家B所画的红色符号，过去进行召唤，等待玩家B进入玩家A的世界来。</li>
<li>玩家B进入玩家A的世界后，玩家A将“王之卢恩”“放置原地”，等玩家B拾取，玩家B拾取后，返回自己的世界。</li>
<li>玩家A等待玩家B返回自己的世界后，正常退出游戏。</li>
<li>玩家A用之前复制的ER0000.sl2替换当前文件夹中的ER0000.sl2。</li>
<li>重新进入游戏，此时玩家A的“王之卢恩”又回来了，玩家B画符，玩家A召唤。</li>
<li>这时候是玩家B将“王之卢恩”“放置原地”，由玩家A拾取，玩家A此时的“王之卢恩”变成双倍了。</li>
<li>玩家B返回自己的世界，玩家A坐一下赐福，返回游戏的标题页面，“请按任意按钮”那个页面，返回电脑桌面，将文件夹刷新一下，重新备份ER0000.sl2文件。再进入页面。</li>
<li>重复以上步骤，直到玩家A拥有699个。</li>
<li>当玩家A有了699个后，备份当前存档，进入游戏，召唤玩家B，再给玩家B“王之卢恩”，玩家B拿到后返回自己的世界，玩家A需要坐赐福从箱子里面再取出“王之卢恩”，召唤玩家B。依次重复进行。这里需要注意的是，玩家A坐赐福取卢恩后，不需要重新使用“唤勾指药”，等玩家B画符就行。</li>
<li>当玩家B也699个后，玩家A再把之前的存档覆盖回来，那么，两个人就都是699个“王之卢恩”了。</li>
</ul>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>请确保“唤勾指药”的数量，拿“落叶花”进行制作，这玩意儿到处都是，也可以去“壶村”刷。</li>
<li>如果想保存游戏存档，只坐赐福是不管用的，得回到标题页面才行。</li>
<li>服务器的稳定性决定刷卢恩的时间。</li>
<li>一定要用“斗士勾指”画符，不然会被其他玩家入侵，链接起来更慢。</li>
</ul>
<p>最后祝各位小伙伴刷的开心，玩的飞起！</p>
]]></content>
      <categories>
        <category>游戏时间</category>
      </categories>
      <tags>
        <tag>Elden Ring</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-判断常用APP是否安装</title>
    <url>/2021/02/25/android-app-installation/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装微信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isWxInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PackageManager</span> <span class="variable">packagemanager</span> <span class="operator">=</span> context.getPackageManager();<span class="comment">// 获取packagemanager</span></span><br><span class="line">    List&lt;PackageInfo&gt; pinfo = packagemanager.getInstalledPackages(<span class="number">0</span>);<span class="comment">// 获取所有已安装程序的包信息</span></span><br><span class="line">    <span class="keyword">if</span> (pinfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pinfo.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pn</span> <span class="operator">=</span> pinfo.get(i).packageName;</span><br><span class="line">            <span class="keyword">if</span> (pn.equals(<span class="string">&quot;com.tencent.mm&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测是否安装支付宝</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAliPayInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;alipays://platformapi/startApp&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);</span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">componentName</span> <span class="operator">=</span> intent.resolveActivity(context.getPackageManager());</span><br><span class="line">    <span class="keyword">return</span> componentName != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="腾讯地图"><a href="#腾讯地图" class="headerlink" title="腾讯地图"></a>腾讯地图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装腾讯地图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isTencentInstall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/data/com.tencent.map&quot;</span>).exists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装QQ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isQQInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PackageManager</span> <span class="variable">packageManager</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line">    List&lt;PackageInfo&gt; pinfo = packageManager.getInstalledPackages(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pinfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pinfo.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pn</span> <span class="operator">=</span> pinfo.get(i).packageName;</span><br><span class="line">            <span class="keyword">if</span> (pn.equalsIgnoreCase(<span class="string">&quot;com.tencent.qqlite&quot;</span>) || pn.equalsIgnoreCase(<span class="string">&quot;com.tencent.mobileqq&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装新浪微博</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSinaInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PackageManager</span> <span class="variable">packageManager</span> <span class="operator">=</span> context.getPackageManager();<span class="comment">// 获取packagemanager</span></span><br><span class="line">    List&lt;PackageInfo&gt; pinfo = packageManager.getInstalledPackages(<span class="number">0</span>);<span class="comment">// 获取所有已安装程序的包信息</span></span><br><span class="line">    <span class="keyword">if</span> (pinfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pinfo.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pn</span> <span class="operator">=</span> pinfo.get(i).packageName;</span><br><span class="line">            <span class="keyword">if</span> (pn.equals(<span class="string">&quot;com.sina.weibo&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装高德地图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isAmapInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    PackageInfo packageInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packageInfo = context.getPackageManager().getPackageInfo(<span class="string">&quot;com.autonavi.minimap&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        packageInfo = <span class="literal">null</span>;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="百度地图"><a href="#百度地图" class="headerlink" title="百度地图"></a>百度地图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装百度地图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isBDMapInstall</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    PackageInfo packageInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packageInfo = context.getPackageManager().getPackageInfo(<span class="string">&quot;com.baidu.BaiduMap&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        packageInfo = <span class="literal">null</span>;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据包名判断该APP是否安装"><a href="#根据包名判断该APP是否安装" class="headerlink" title="根据包名判断该APP是否安装"></a>根据包名判断该APP是否安装</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否安装了这个应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packagename</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isInstall</span><span class="params">(Context context, String packagename)</span> &#123;</span><br><span class="line">    PackageInfo packageInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        packageInfo = context.getPackageManager().getPackageInfo(packagename, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        packageInfo = <span class="literal">null</span>;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-CameraX相机功能</title>
    <url>/2021/03/01/android-camerax/</url>
    <content><![CDATA[<p>工作以来，好几个项目中，都使用到了相机功能，进行拍照，或者二维码扫描等等。以前总是使用GitHub上的开源库，直到同事和我说，JetPack里面出了一个CameraX，又碰巧遇到了扫描二维码的需求，学习并使用了一下，做了一个二维码扫描库，并且带有解析功能：<a href="https://github.com/hijiaopeng/QRScan">QRScan</a>。</p>
<span id="more"></span>

<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>CameraX向下兼容到5.0（API 21），里面利用的是Camera2的功能，但是使用的是更为简单且基于用例的方法，这些方法具有生命周期感知能力，因此我们不必再着重于生命周期管理上。解决了设备兼容性问题，不用为了适配不同厂商写if-else了。</p>
<p>目前是Beta版，在版本的升级中，存在部分函数和使用的不同，并可能发生意外的错误。不过还是可以使用的，整体不影响功能的实现。</p>
<h4 id="声明依赖项"><a href="#声明依赖项" class="headerlink" title="声明依赖项"></a>声明依赖项</h4><p>打开项目的 <code>build.gradle</code> 文件并添加 <code>google()</code> 代码库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以下内容添加到 Android 代码块的末尾，配置java-1.8环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For Kotlin projects</span></span><br><span class="line">kotlinOptions &#123;</span><br><span class="line">    jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以下内容添加所需应用模块的 <code>build.gradle</code> 文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// CameraX core library using the camera2 implementation</span></span><br><span class="line">  <span class="type">def</span> <span class="variable">camerax_version</span> <span class="operator">=</span> <span class="string">&quot;1.0.0-rc02&quot;</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.camera:camera-view:1.0.0-alpha21&quot;</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.camera:camera-extensions:1.0.0-alpha21&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：实际版本请自行查询更换。</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>使用相机功能，不要忘记添加权限的支持：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="绘制取景器布局"><a href="#绘制取景器布局" class="headerlink" title="绘制取景器布局"></a>绘制取景器布局</h4><p>在<code>xml</code>文件里面添加<code>PreviewView</code>组件，用于显示图像预览:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/scanCameraPreview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置CameraX实例"><a href="#配置CameraX实例" class="headerlink" title="配置CameraX实例"></a>配置CameraX实例</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将摄像机的生命周期绑定到生命周期所有者，不必担心打开和关闭了</span></span><br><span class="line">   <span class="keyword">val</span> cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">   cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">       <span class="comment">// 将相机的生命周期绑定到应用程序进程中的LifecycleOwner</span></span><br><span class="line">       <span class="keyword">val</span> cameraProvider: ProcessCameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">       <span class="comment">// Preview</span></span><br><span class="line">       preview = Preview.Builder()</span><br><span class="line">           .build()</span><br><span class="line">       <span class="comment">// 选择后置摄像头</span></span><br><span class="line">       <span class="keyword">val</span> cameraSelector = CameraSelector.Builder().requireLensFacing(CameraSelector.LENS_FACING_BACK).build()</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           cameraProvider.unbindAll()</span><br><span class="line">      preview?.setSurfaceProvider(viewFinder.createSurfaceProvider(camera?.cameraInfo))</span><br><span class="line">         <span class="comment">//	这里就是打开相机，展示预览了</span></span><br><span class="line">           camera = cameraProvider.bindToLifecycle(</span><br><span class="line">               <span class="keyword">this</span>, cameraSelector, preview)</span><br><span class="line">       &#125; <span class="keyword">catch</span>(exc: Exception) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">&quot;Use case binding failed&quot;</span>, exc)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析图片ImageAnalysis-Analyzer"><a href="#分析图片ImageAnalysis-Analyzer" class="headerlink" title="分析图片ImageAnalysis.Analyzer"></a>分析图片ImageAnalysis.Analyzer</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageAnalysis = ImageAnalysis.Builder()</span><br><span class="line">		<span class="comment">// 设置目标分辨率</span></span><br><span class="line">    .setTargetResolution(Size(<span class="number">1280</span>, <span class="number">720</span>))</span><br><span class="line">		<span class="comment">// STRATEGY_BLOCK_PRODUCER：启用阻塞模式。在此模式下，执行器会依序从相应相机接收帧；			// 这意味着，如果 analyze() 方法所用的时间超过单帧在当前帧速率下的延迟时间，所接收的帧便		 // 可能不再是最新的帧，因为在该方法返回之前，新帧会被阻止进入流水线。</span></span><br><span class="line">		<span class="comment">// STRATEGY_KEEP_ONLY_LATEST：启用非阻塞模式。在此模式下，执行程序在调用 analyze() 		 // 方法时会从相机接收最新的可用帧。如果此方法所用的时间超过单帧在当前帧速率下的延迟时间，			// 它可能会跳过某些帧，以便 analyze() 在下一次接收数据时获取相机流水线中的最新可用帧。</span></span><br><span class="line">    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">imageAnalysis.setAnalyzer(executor, ImageAnalysis.Analyzer &#123; image -&gt;</span><br><span class="line">    <span class="keyword">val</span> rotationDegrees = image.imageInfo.rotationDegrees</span><br><span class="line">    <span class="comment">// insert your code here.</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cameraProvider.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, imageAnalysis, preview)</span><br></pre></td></tr></table></figure>

<h4 id="图片拍摄"><a href="#图片拍摄" class="headerlink" title="图片拍摄"></a>图片拍摄</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置ImageCapture。</span></span><br><span class="line"><span class="comment">// 如需缩短照片拍摄的延迟时间，请将 ImageCapture.CaptureMode 设置为 CAPTURE_MODE_MINIMIZE_LATENCY。</span></span><br><span class="line"><span class="comment">// 如需优化照片质量，请将其设置为 CAPTURE_MODE_MAXIMIZE_QUALITY。</span></span><br><span class="line"><span class="keyword">val</span> imageCapture = ImageCapture.Builder()</span><br><span class="line">    .setTargetRotation(view.display.rotation)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">cameraProvider.bindToLifecycle(lifecycleOwner, cameraSelector, imageCapture,</span><br><span class="line">    imageAnalysis, preview)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行拍摄图片</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> outputFileOptions = ImageCapture.OutputFileOptions.Builder(File(...)).build()</span><br><span class="line">    imageCapture.takePicture(outputFileOptions, cameraExecutor,</span><br><span class="line">        <span class="keyword">object</span> : ImageCapture.OnImageSavedCallback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">ImageCaptureException</span>)</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 拍照失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onImageSaved</span><span class="params">(outputFileResults: <span class="type">ImageCapture</span>.<span class="type">OutputFileResults</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 拍照保存成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>大体常用的基础功能就这些了，其他扩展可以参考官方文档：<a href="https://developer.android.google.cn/training/camerax">CameraX</a>，代码相对来说的确优化了很多，并且最让人头疼的生命周期也帮我们做了处理。开发者还可以通过扩展的形式使用和原生摄像头同样的功能（人像、夜间模式、HDR、滤镜、美颜等等）。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio项目中导入aar包</title>
    <url>/2021/05/07/android-build-aar/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h4><p>找到module的build.gradle文件，在dependencies{}里面直接添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation fileTree(include: [<span class="string">&#x27;*.jar&#x27;</span>,<span class="string">&quot;*.aar&quot;</span>], dir: <span class="string">&#x27;libs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h4><p>找到项目的build.gradle文件，添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">    		...</span><br><span class="line">    		flatDir &#123;</span><br><span class="line">            dirs <span class="string">&#x27;libs&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用到的对应module的build.gradle文件里面添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">		 implementation(name: <span class="string">&#x27;aar名字&#x27;</span>, ext: <span class="string">&#x27;aar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：此种方法适用于单一module引入aar文件。如果引入aar的是一个moduleA，这个moduleA又被其他module引用，项目就会编译失败，所以在多module下，使用下面这种方式。</p>
<h4 id="第三种方式："><a href="#第三种方式：" class="headerlink" title="第三种方式："></a>第三种方式：</h4><p>修改项目的build.gradle文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">    		...</span><br><span class="line">    		flatDir &#123;</span><br><span class="line">    				<span class="comment">//这里需要把引入了aar包的module添加到依赖关系中</span></span><br><span class="line">            dirs project(<span class="string">&#x27;:xxModule&#x27;</span>).file(<span class="string">&#x27;libs&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xxModule的build.gradle文件里面添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">		 implementation(name: <span class="string">&#x27;aar名字&#x27;</span>, ext: <span class="string">&#x27;aar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此完成。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-关于混淆的理解和使用</title>
    <url>/2021/02/25/android-garble-use/</url>
    <content><![CDATA[<p>Android Studio使用Proguard进行代码混淆，是一个压缩，优化，混淆Java字节码文件的工具。混淆配置在proguard-rules.pro文件中。</p>
<p>通过混淆，可以防止APP被反编译等手段逆向破解，混淆后，代码中原来有具体含义的包名，类名，方法名，变量名等等名称将变成按顺序排列的无意义的英文字母，从而增加阅读的难度，保护程序的安全性。</p>
<span id="more"></span>

<p>首先需要在build.gradle–buildTypes目录下，打开minifyEnabled true（代码混淆），shrinkResources true（资源缩减，移除没用的资源文件，必须和minifyEnabled 一起使用），zipAlignEnabled true（对APK包进行对齐优化，提高运行效率）。proguardFilesgetDefaultProguardFile(‘proguard-android.txt’),’proguard-rules.pro’</p>
<p>前半段代表系统默认的混淆文件，该文件中包含了基本的混淆声明，后一部分是我们自己定义的混淆文件。</p>
<p>注意点：在minifyEnabled置为false的情况下，zipAlignEnabled 和 shrinkResources 也要置为false，否则会编译报错。</p>
<p>最好在debug模式下也开启混淆进行测试，防止release时发生错误。</p>
<p>关于shrinkResources true：在res&#x2F;raw&#x2F;下创建一个keep.xml文件，该文件不会被打包进APK中，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">tools:discard</span>=<span class="string">&quot;@color/selector_tint_color&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">tools:keep</span>=<span class="string">&quot;@layout/activity_test1,@layout/activity_test2&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">tools:shrinkMode</span>=<span class="string">&quot;strict&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--discard：做严格检查--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--keep :不做严格检查--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--shrinkMode=&quot;strict&quot; :该模式只保留在代码或者资源文件中明确引用的资源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--shrinkMode=&quot;safe&quot; :该模式会保留所有明确引用的资源以及可能被 Resources.getIdentifier() 动态引用的资源--&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="基本配置模板："><a href="#基本配置模板：" class="headerlink" title="基本配置模板："></a>基本配置模板：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#指定代码的压缩级别<span class="number">0</span>-<span class="number">7</span>(指定代码进行迭代优化的次数，在Android里面默认是<span class="number">5</span>，这条指令也只有在可以优化时起作用。)</span><br><span class="line">-optimizationpasses5</span><br><span class="line"></span><br><span class="line">#混淆时不会产生形形色色的类名(混淆时不使用大小写混合类名)</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line">#指定不去忽略非公共的库类(不跳过library中的非<span class="keyword">public</span>的类)</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line">#指定不去忽略包可见的库类的成员</span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"></span><br><span class="line">#不进行优化，建议使用此选项，</span><br><span class="line">-dontoptimize</span><br><span class="line"></span><br><span class="line">#不进行预校验,Android不需要,可加快混淆速度。</span><br><span class="line">-dontpreverify</span><br><span class="line"></span><br><span class="line">#混淆时记录日志(打印混淆的详细信息)</span><br><span class="line">#这句话能够使我们的项目混淆后产生映射文件</span><br><span class="line">#包含有类名-&gt;混淆后类名的映射关系</span><br><span class="line">-verbose</span><br><span class="line">-printmappingpriguardMapping.txt</span><br><span class="line"></span><br><span class="line">#指定混淆时采用的算法，后面的参数是一个过滤器</span><br><span class="line">#这个过滤器是谷歌推荐的算法，一般不改变</span><br><span class="line">-optimizations!code/simplification/cast,!field<span class="comment">/*,!class/merging/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#错误显示行号</span></span><br><span class="line"><span class="comment">-keepattributesSourceFile,LineNumberTable</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#屏蔽警告</span></span><br><span class="line"><span class="comment">-ignorewarnings</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置是否允许改变作用域</span></span><br><span class="line"><span class="comment">-allowaccessmodification</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#把混淆类中的方法名也混淆了</span></span><br><span class="line"><span class="comment">-useuniqueclassmembernames</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#apk包内所有class的内部结构</span></span><br><span class="line"><span class="comment">-dumpclass_files.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#未混淆的类和成员</span></span><br><span class="line"><span class="comment">-printseedsseeds_txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#列出从apk中删除的代码</span></span><br><span class="line"><span class="comment">-printusageunused.txt</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-----------------------------默认保留-----------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#保持哪些类不被混淆</span></span><br><span class="line"><span class="comment">#继承activity,application,service,broadcastReceiver,contentprovider....不进行混淆</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.app.Activity</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.app.Application</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.support.multidex.MultiDexApplication</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.app.Service</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.content.BroadcastReceiver</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.content.ContentProvider</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.app.backup.BackupAgentHelper</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.preference.Preference</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.view.View</span></span><br><span class="line"><span class="comment">-keepclassandroid.support.**&#123;*;&#125;##保留support下的所有类及其内部类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-keeppublicclasscom.google.vending.licensing.ILicensingService</span></span><br><span class="line"><span class="comment">-keeppublicclasscom.android.vending.licensing.ILicensingService</span></span><br><span class="line"><span class="comment">#表示不混淆上面声明的类，最后这两个类我们基本也用不上，是接入Google原生的一些服务时使用的。</span></span><br><span class="line"><span class="comment">#----------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保留继承的</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.support.v4.**</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.support.v7.**</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.support.annotation.**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Androidx</span></span><br><span class="line"><span class="comment">-keepclasscom.google.android.material.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keepclassandroidx.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroidx.**</span></span><br><span class="line"><span class="comment">-keepinterfaceandroidx.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-dontwarncom.google.android.material.**</span></span><br><span class="line"><span class="comment">-dontnotecom.google.android.material.**</span></span><br><span class="line"><span class="comment">-dontwarnandroidx.**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#supportdesign</span></span><br><span class="line"><span class="comment">-keepclassandroid.support.design.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keepinterfaceandroid.support.design.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keeppublicclassandroid.support.design.R$*&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-dontwarnandroid.support.design.**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#这个主要是在layout中写的onclick方法android:onclick=&quot;onClick&quot;，不进行混淆</span></span><br><span class="line"><span class="comment">#表示不混淆Activity中参数是View的方法，因为有这样一种用法，在XML中配置android:onClick=”buttonClick”属性，</span></span><br><span class="line"><span class="comment">#当用户点击该按钮时就会调用Activity中的buttonClick(Viewview)方法，如果这个方法被混淆的话就找不到了</span></span><br><span class="line"><span class="comment">-keepclassmembersclass*extendsandroid.app.Activity&#123;</span></span><br><span class="line"><span class="comment">publicvoid*(android.view.View);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保护代码中的Annotation不被混淆</span></span><br><span class="line"><span class="comment">#这在JSON实体映射时非常重要，比如fastJson</span></span><br><span class="line"><span class="comment">-keepattributesAnnotation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">################annotation###############</span></span><br><span class="line"><span class="comment">-keepclassandroid.support.annotation.*&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keepclassandroidx.annotation.*&#123;*;&#125;</span></span><br><span class="line"><span class="comment">-keepinterfaceandroid.support.annotation.*&#123;*;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#避免混淆泛型</span></span><br><span class="line"><span class="comment">#这在JSON实体映射时非常重要，比如fastJson</span></span><br><span class="line"><span class="comment">-keepattributesSignature</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保留所有的本地native方法不被混淆</span></span><br><span class="line"><span class="comment">-keepclasseswithmembernamesclass*&#123;</span></span><br><span class="line"><span class="comment">native&lt;methods&gt;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#枚举类不能被混淆</span></span><br><span class="line"><span class="comment">-keepclassmembersenum*&#123;</span></span><br><span class="line"><span class="comment">publicstatic**[]values();</span></span><br><span class="line"><span class="comment">publicstatic**valueOf(java.lang.String);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保留R下面的资源</span></span><br><span class="line"><span class="comment">-keepclass**.R$*&#123;</span></span><br><span class="line"><span class="comment">*;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#不混淆资源类下static的</span></span><br><span class="line"><span class="comment">-keepclassmembersclass**.R$*&#123;</span></span><br><span class="line"><span class="comment">publicstatic&lt;fields&gt;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#表示不混淆任何一个View中的setXxx()和getXxx()方法，</span></span><br><span class="line"><span class="comment">#因为属性动画需要有相应的setter和getter的方法实现，混淆了就无法工作了。</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.view.View&#123;</span></span><br><span class="line"><span class="comment">***get*();</span></span><br><span class="line"><span class="comment">voidset*(***);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet,int);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">-keepclasseswithmembersclass*&#123;</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet,int);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#表示不混淆Parcelable实现类中的CREATOR字段，</span></span><br><span class="line"><span class="comment">#毫无疑问，CREATOR字段是绝对不能改变的，包括大小写都不能变，不然整个Parcelable工作机制都会失败。</span></span><br><span class="line"><span class="comment">-keepclass*implementsandroid.os.Parcelable&#123;</span></span><br><span class="line"><span class="comment">publicstaticfinalandroid.os.Parcelable$Creator*;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#这指定了继承Serizalizable的类的如下成员不被移除混淆</span></span><br><span class="line"><span class="comment">-keepclassmembersclass*implementsjava.io.Serializable&#123;</span></span><br><span class="line"><span class="comment">staticfinallongserialVersionUID;</span></span><br><span class="line"><span class="comment">privatestaticfinaljava.io.ObjectStreamField[]serialPersistentFields;</span></span><br><span class="line"><span class="comment">privatevoidwriteObject(java.io.ObjectOutputStream);</span></span><br><span class="line"><span class="comment">privatevoidreadObject(java.io.ObjectInputStream);</span></span><br><span class="line"><span class="comment">java.lang.ObjectwriteReplace();</span></span><br><span class="line"><span class="comment">java.lang.ObjectreadResolve();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆</span></span><br><span class="line"><span class="comment">-keepclassmembersclass*&#123;</span></span><br><span class="line"><span class="comment">void*(**On*Event);</span></span><br><span class="line"><span class="comment">void*(**On*Listener);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保留我们自定义控件（继承自View）不被混淆</span></span><br><span class="line"><span class="comment">-keeppublicclass*extendsandroid.view.View&#123;</span></span><br><span class="line"><span class="comment">***get*();</span></span><br><span class="line"><span class="comment">voidset*(***);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet);</span></span><br><span class="line"><span class="comment">public&lt;init&gt;(android.content.Context,android.util.AttributeSet,int);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-----------------------------WebView(项目中没有可以忽略)-----------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#webView需要进行特殊处理</span></span><br><span class="line"><span class="comment">-keepclassmembersclassfqcn.of.javascript.interface.for.webview&#123;</span></span><br><span class="line"><span class="comment">public*;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">-keepclassmembersclass*extendsandroid.webkit.WebViewClient&#123;</span></span><br><span class="line"><span class="comment">publicvoid*(android.webkit.WebView,java.lang.String,android.graphics.Bitmap);</span></span><br><span class="line"><span class="comment">publicboolean*(android.webkit.WebView,java.lang.String);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">-keepclassmembersclass*extendsandroid.webkit.WebViewClient&#123;</span></span><br><span class="line"><span class="comment">publicvoid*(android.webkit.WebView,java.lang.String);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#在app中与HTML5的JavaScript的交互进行特殊处理</span></span><br><span class="line"><span class="comment">#我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理：</span></span><br><span class="line"><span class="comment">#-keepclassmembersclasscom.ljd.example.JSInterface&#123;</span></span><br><span class="line"><span class="comment">#&lt;methods&gt;;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#JS调用Java方法</span></span><br><span class="line"><span class="comment">-keepattributes*JavascriptInterface*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#---------------------------------实体类---------------------------------</span></span><br><span class="line"><span class="comment">#--------(实体Model不能混淆，否则找不到对应的属性获取不到值)-----</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-dontwarncom.suchengkeji.android.confusiondemo.md.**</span></span><br><span class="line"><span class="comment">#对含有反射类的处理</span></span><br><span class="line"><span class="comment">#-keepclasscom.suchengkeji.android.confusiondemo.md.**&#123;*;&#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-----------------------------其他的-----------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#删除代码中Log相关的代码</span></span><br><span class="line"><span class="comment">-assumenosideeffectsclassandroid.util.Log&#123;</span></span><br><span class="line"><span class="comment">publicstaticbooleanisLoggable(java.lang.String,int);</span></span><br><span class="line"><span class="comment">publicstaticintv(...);</span></span><br><span class="line"><span class="comment">publicstaticinti(...);</span></span><br><span class="line"><span class="comment">publicstaticintw(...);</span></span><br><span class="line"><span class="comment">publicstaticintd(...);</span></span><br><span class="line"><span class="comment">publicstaticinte(...);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保持测试相关的代码</span></span><br><span class="line"><span class="comment">#-dontnotejunit.framework.**</span></span><br><span class="line"><span class="comment">#-dontnotejunit.runner.**</span></span><br><span class="line"><span class="comment">#-dontwarnandroid.test.**</span></span><br><span class="line"><span class="comment">#-dontwarnandroid.support.test.**</span></span><br><span class="line"><span class="comment">#-dontwarnorg.junit.**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#-----------------------------第三方-----------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">...</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-设置.gitignore忽略文件</title>
    <url>/2021/02/25/android-gitignore/</url>
    <content><![CDATA[<p>之前使用Github for Windows的时候，直接创建一个目录，就开始往里面放项目，也没有考虑过设置忽略文件，倒是很久之前，刚开始做项目时，因为是两个人一起开发，所以设置的SVN的忽略文件。 最近要开始新的项目，又因为是在Mac上开发，最后还需要放到公司的Windows电脑上，所以好好梳理了一下忽略文件这个知识点，方便项目的多端开发使用。</p>
<span id="more"></span>

<h3 id="基本需要忽略的文件"><a href="#基本需要忽略的文件" class="headerlink" title="基本需要忽略的文件"></a>基本需要忽略的文件</h3><ul>
<li>.gradle&#x2F;下的所有文件</li>
<li>.idea&#x2F;下的所有文件</li>
<li>所有的build下的文件</li>
<li>local.properties</li>
<li>所有的.iml文件</li>
</ul>
<p>我们需要将以上文件忽略掉，这样在重新档下项目后，顺利的进行编译。</p>
<h3 id="配置-gitignore文件"><a href="#配置-gitignore文件" class="headerlink" title="配置.gitignore文件"></a>配置.gitignore文件</h3><h4 id="手动配置："><a href="#手动配置：" class="headerlink" title="手动配置："></a>手动配置：</h4><p>可以参考：<a href="https://github.com/github/gitignore%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E5%90%84%E7%A7%8D.gitignore%E6%A8%A1%E6%9D%BF%EF%BC%8C%E6%89%BE%E5%88%B0Android%E7%9A%84%E5%B0%B1%E8%A1%8C%EF%BC%8C%E5%9C%A8%E5%85%A8%E5%B1%80%E7%9A%84.gitignore%E6%96%87%E4%BB%B6%E4%B8%AD%E9%87%8D%E5%86%99%E3%80%82">https://github.com/github/gitignore，里面有各种.gitignore模板，找到Android的就行，在全局的.gitignore文件中重写。</a> Android.gitignore：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Built application files</span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line">*.aab</span><br><span class="line"></span><br><span class="line"># Files <span class="keyword">for</span> the ART/Dalvik VM</span><br><span class="line">*.dex</span><br><span class="line"></span><br><span class="line"># Java <span class="keyword">class</span> <span class="title class_">files</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Generated files</span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"># Gradle files</span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># Local configuration <span class="title function_">file</span> <span class="params">(sdk path, etc)</span></span><br><span class="line">local.properties</span><br><span class="line"></span><br><span class="line"># Proguard folder generated by Eclipse</span><br><span class="line">proguard/</span><br><span class="line"></span><br><span class="line"># Log Files</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># Android Studio Navigation editor temp files</span><br><span class="line">.navigation/</span><br><span class="line"></span><br><span class="line"># Android Studio captures folder</span><br><span class="line">captures/</span><br><span class="line"></span><br><span class="line"># IntelliJ</span><br><span class="line">*.iml</span><br><span class="line">.idea/workspace.xml</span><br><span class="line">.idea/tasks.xml</span><br><span class="line">.idea/gradle.xml</span><br><span class="line">.idea/assetWizardSettings.xml</span><br><span class="line">.idea/dictionaries</span><br><span class="line">.idea/libraries</span><br><span class="line">.idea/caches</span><br><span class="line"></span><br><span class="line"># Keystore files</span><br><span class="line"># Uncomment the following lines <span class="keyword">if</span> you <span class="keyword">do</span> not want to check your keystore files in.</span><br><span class="line">#*.jks</span><br><span class="line">#*.keystore</span><br><span class="line"></span><br><span class="line"># External <span class="keyword">native</span> build folder generated in Android Studio <span class="number">2.2</span> and later</span><br><span class="line">.externalNativeBuild</span><br><span class="line"></span><br><span class="line"># Google <span class="title function_">Services</span> <span class="params">(e.g. APIs or Firebase)</span></span><br><span class="line">google-services.json</span><br><span class="line"></span><br><span class="line"># Freeline</span><br><span class="line">freeline.py</span><br><span class="line">freeline/</span><br><span class="line">freeline_project_description.json</span><br><span class="line"></span><br><span class="line"># fastlane</span><br><span class="line">fastlane/report.xml</span><br><span class="line">fastlane/Preview.html</span><br><span class="line">fastlane/screenshots</span><br><span class="line">fastlane/test_output</span><br><span class="line">fastlane/readme.md</span><br></pre></td></tr></table></figure>

<p>会出现的问题：<br>有时候添加完成后，提交代码发现并没有进行忽略，解决方式就是清除一下缓存，原因gitignore对已经追踪(track)的文件无效，清除缓存后文件将以未追踪的形式出现.然后再重新添加提交一下,.gitignore文件里的规则就可以起作用了。</p>
<p>执行以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[路径]git rm -r --cached .</span><br><span class="line">[路径]git add .</span><br><span class="line">[路径]git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>

<p>目前我还没遇到过这种问题，待确认是否可行。</p>
<h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>当我们在Github上创建一个新的目录时，下面有一个选项，如图：</p>
<p>直接设置为Android即可。 接下来是在本地创建项目，会弹出一个提示框，如图：<br>选择“proceed”。<br>项目创建完成后，可以看到根目录的.gitignore文件为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Built application files</span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line"></span><br><span class="line"># Files <span class="keyword">for</span> the ART/Dalvik VM</span><br><span class="line">*.dex</span><br><span class="line"></span><br><span class="line"># Java <span class="keyword">class</span> <span class="title class_">files</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Generated files</span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"># Gradle files</span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># Local configuration <span class="title function_">file</span> <span class="params">(sdk path, etc)</span></span><br><span class="line">local.properties</span><br><span class="line"></span><br><span class="line"># Proguard folder generated by Eclipse</span><br><span class="line">proguard/</span><br><span class="line"></span><br><span class="line"># Log Files</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># Android Studio Navigation editor temp files</span><br><span class="line">.navigation/</span><br><span class="line"></span><br><span class="line"># Android Studio captures folder</span><br><span class="line">captures/</span><br><span class="line"></span><br><span class="line"># IntelliJ</span><br><span class="line">*.iml</span><br><span class="line">.idea/workspace.xml</span><br><span class="line">.idea/tasks.xml</span><br><span class="line">.idea/gradle.xml</span><br><span class="line">.idea/assetWizardSettings.xml</span><br><span class="line">.idea/dictionaries</span><br><span class="line">.idea/libraries</span><br><span class="line">.idea/caches</span><br><span class="line"></span><br><span class="line"># Keystore files</span><br><span class="line"># Uncomment the following line <span class="keyword">if</span> you <span class="keyword">do</span> not want to check your keystore files in.</span><br><span class="line">#*.jks</span><br><span class="line"></span><br><span class="line"># External <span class="keyword">native</span> build folder generated in Android Studio <span class="number">2.2</span> and later</span><br><span class="line">.externalNativeBuild</span><br><span class="line"></span><br><span class="line"># Google <span class="title function_">Services</span> <span class="params">(e.g. APIs or Firebase)</span></span><br><span class="line">google-services.json</span><br><span class="line"></span><br><span class="line"># Freeline</span><br><span class="line">freeline.py</span><br><span class="line">freeline/</span><br><span class="line">freeline_project_description.json</span><br><span class="line"></span><br><span class="line"># fastlane</span><br><span class="line">fastlane/report.xml</span><br><span class="line">fastlane/Preview.html</span><br><span class="line">fastlane/screenshots</span><br><span class="line">fastlane/test_output</span><br><span class="line">fastlane/readme.md</span><br></pre></td></tr></table></figure>

<p>至此完成配置。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-使用华为的扫描功能</title>
    <url>/2021/05/11/android-huawei-scan/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于扫描二维码功能，我们最多使用的就是ZXing了，有位同事说，你可以再尝试一下华为出的Scan Kit，据说两米开外都能扫描到，很是强大。对于这么NB的功能技术，我也忍不住体验了一把，最后感觉是：真的香…</p>
<span id="more"></span>

<h4 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h4><p>华为HMS Core官方文档，统一扫码服务：<a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides-V5/service-introduction-0000001050041994-V5">https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides-V5/service-introduction-0000001050041994-V5</a></p>
<h4 id="集成SDK"><a href="#集成SDK" class="headerlink" title="集成SDK"></a>集成SDK</h4><p>在项目的build.gradle文件中添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 配置HMS Core SDK的Maven仓地址。</span></span><br><span class="line">        maven &#123;url <span class="string">&#x27;https://developer.huawei.com/repo/&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 配置HMS Core SDK的Maven仓地址。</span></span><br><span class="line">        maven &#123;url <span class="string">&#x27;https://developer.huawei.com/repo/&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在Module的build.gradle文件中添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.huawei.hms:scanplus:1.3.2.300&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：请自行查找最新的版本号。</p>
<p>华为Scan Kit提供两种SDK：<strong>Scan SDK-Plus</strong>和<strong>Scan SDK</strong>，区别在于：</p>
<p><img data-src="https://www.hualigs.cn/image/609a20c1cd1a0.jpg"></p>
<p>当然，为了适配到其他机型，我们选择的是plus版本。</p>
<h4 id="配置混淆"><a href="#配置混淆" class="headerlink" title="配置混淆"></a>配置混淆</h4><p>找到proguard-rules.pro文件添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">-ignorewarnings</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keepattributes Exceptions</span><br><span class="line">-keepattributes InnerClasses</span><br><span class="line">-keepattributes Signature</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">huawei</span>.<span class="title">hianalytics</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">huawei</span>.<span class="title">updatesdk</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">huawei</span>.<span class="title">hms</span>.**</span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>

<p>如果还使用了AndResGuard，需要在项目的“build.gradle”文件中加入AndResGuard允许清单：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;R.string.hms*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.string.connect_server_fail_prompt_toast&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.string.getting_message_fail_prompt_toast&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.string.no_available_network_prompt_toast&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.string.third_app_*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.string.upsdk_*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.layout.hms*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.layout.upsdk_*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.drawable.upsdk*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.color.upsdk*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.dimen.upsdk*&quot;</span>,</span><br><span class="line"><span class="string">&quot;R.style.upsdk*&quot;</span>, </span><br><span class="line"><span class="string">&quot;R.string.agc*&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="指定权限"><a href="#指定权限" class="headerlink" title="指定权限"></a>指定权限</h4><p>在AndroidManifest.xml文件中先指定所需的权限：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;!--相机权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span><br><span class="line">&lt;!--读写文件权限，在需要识别本地相册图片功能时添加--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>后续在编写功能代码时，不要忘记动态申请权限。</p>
<h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><h5 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h5><p>极其简单的实现扫码功能，UI页面使用的SDK里面的，需要开启硬件加速，在AndroidManifest.xml文件中添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        ...</span><br><span class="line">				android:hardwareAccelerated=<span class="string">&quot;true&quot;</span></span><br><span class="line">				&gt;</span><br><span class="line">       </span><br><span class="line">				...</span><br><span class="line"></span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>配置扫码参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Scan Kit默认支持13种码制式，开发者也可以指定Scan Kit只扫描特定的码制式以提高扫码速度</span></span><br><span class="line"><span class="comment">//这里“QRCODE_SCAN_TYPE”和“DATAMATRIX_SCAN_TYPE”表示只扫描QR和Data Matrix的码</span></span><br><span class="line"><span class="keyword">val</span> options = HmsScanAnalyzerOptions.Creator().setHmsScanTypes(HmsScan.QRCODE_SCAN_TYPE , HmsScan.DATAMATRIX_SCAN_TYPE).create()</span><br></pre></td></tr></table></figure>

<p>启动扫码页面：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//REQUEST_CODE_SCAN_ONE：对应“onActivityResult”方法中的“requestCode”参数，用于判断“onActivityResult”调用是否来自Scan Kit扫码结果回调</span></span><br><span class="line"><span class="comment">//如果没有指定检测特定的码制式，此处的“options”可以置为“null”，表示默认检测Scan Kit支持的码制式。</span></span><br><span class="line">ScanUtil.startScan(<span class="keyword">this</span>, REQUEST_CODE_SCAN_ONE, options)</span><br></pre></td></tr></table></figure>

<p>获取扫码结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode:<span class="type">Int</span>, resultCode:<span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (resultCode != RESULT_OK || <span class="keyword">data</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_SCAN_ONE) &#123;</span><br><span class="line">            <span class="comment">//导入图片扫描返回结果</span></span><br><span class="line">            <span class="keyword">var</span> obj = <span class="keyword">data</span>?.getParcelableExtra(ScanUtil.RESULT) <span class="keyword">as</span> HmsScan?</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//展示解码结果,获取条码原始的全部码值信息</span></span><br><span class="line">                obj.originalValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h5><p>在布局文件中添加全屏的FrameLayout：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/parentView&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/rim&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>代码创建RemoteView：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化RemoteView，并通过如下方法设置参数:setContext()（必选）传入context、setBoundingBox()设置扫描区域、setFormat()设置识别码制式，</span></span><br><span class="line"><span class="comment">//设置完毕调用build()方法完成创建。通过setContinuouslyScan（可选）方法设置非连续扫码模式。</span></span><br><span class="line"><span class="keyword">val</span> remoteView: RemoteView <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="comment">//设置扫码识别区域，您可以按照需求调整参数</span></span><br><span class="line">    <span class="keyword">val</span> dm = resources.displayMetrics</span><br><span class="line">    <span class="keyword">val</span> density = dm.density</span><br><span class="line">    <span class="keyword">val</span> mScreenWidth = resources.displayMetrics.widthPixels</span><br><span class="line">    <span class="keyword">val</span> mScreenHeight = resources.displayMetrics.heightPixels</span><br><span class="line">    <span class="comment">//当前demo扫码框的宽高是300dp</span></span><br><span class="line">    <span class="keyword">val</span> SCAN_FRAME_SIZE = <span class="number">300</span></span><br><span class="line">    <span class="keyword">val</span> scanFrameSize = (SCAN_FRAME_SIZE * density).toInt()</span><br><span class="line">    <span class="keyword">val</span> rect = Rect()</span><br><span class="line">    rect.left = mScreenWidth / <span class="number">2</span> - scanFrameSize / <span class="number">2</span></span><br><span class="line">    rect.right = mScreenWidth / <span class="number">2</span> + scanFrameSize / <span class="number">2</span></span><br><span class="line">    rect.top = mScreenHeight / <span class="number">2</span> - scanFrameSize / <span class="number">2</span></span><br><span class="line">    rect.bottom = mScreenHeight / <span class="number">2</span> + scanFrameSize / <span class="number">2</span></span><br><span class="line">    RemoteView.Builder().setContext(<span class="keyword">this</span>).setBoundingBox(rect).setContinuouslyScan(<span class="literal">false</span>)</span><br><span class="line">        .setFormat(</span><br><span class="line">            HmsScan.QRCODE_SCAN_TYPE, HmsScan.DATAMATRIX_SCAN_TYPE</span><br><span class="line">        ).build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onCreate()里面添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将自定义view加载到activity</span></span><br><span class="line">remoteView.onCreate(savedInstanceState)</span><br><span class="line"><span class="keyword">val</span> params = FrameLayout.LayoutParams(</span><br><span class="line">    LinearLayout.LayoutParams.MATCH_PARENT,</span><br><span class="line">    LinearLayout.LayoutParams.MATCH_PARENT</span><br><span class="line">)</span><br><span class="line">binding.rim.addView(remoteView, params)</span><br></pre></td></tr></table></figure>

<p>注意：View的获取建议使用ViewBinding。</p>
<p>获取扫描结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//识别结果回调事件订阅</span></span><br><span class="line">remoteView.setOnResultCallback &#123;</span><br><span class="line">      <span class="comment">//获取到扫码结果HmsScan</span></span><br><span class="line">      it.forEach &#123; hs-&gt;</span><br><span class="line">         Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;onCreate: <span class="subst">$&#123;hs.originalValue&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描结果会返回一个HmsScan数组，因为它支持一次扫描多个二维码，把每个扫描结果都会获取到，解决了误扫的问题。</p>
<p>其次，还需要管理一下生命周期：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart()</span><br><span class="line">    <span class="comment">//侦听activity的onStart</span></span><br><span class="line">    remoteView.onStart()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    <span class="comment">//侦听activity的onResume</span></span><br><span class="line">    remoteView.onResume()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line">    <span class="comment">//侦听activity的onPause</span></span><br><span class="line">    remoteView.onPause()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop()</span><br><span class="line">    <span class="comment">//侦听activity的onStop</span></span><br><span class="line">    remoteView.onStop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    <span class="comment">//侦听activity的onDestroy</span></span><br><span class="line">    remoteView.onDestroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有这个地方，如果使用lifecycle就更好了。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>目前最常使用到功能就这些，它里面还有别的功能与实现，后续有时间，再完善一下。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Math函数的使用</title>
    <url>/2021/02/25/android-math-use/</url>
    <content><![CDATA[<span id="more"></span>

<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Math.PI;</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.E;</td>
<td>e的常量</td>
</tr>
<tr>
<td>Math.sin();</td>
<td>正弦函数</td>
</tr>
<tr>
<td>Math.cos();</td>
<td>余弦函数</td>
</tr>
<tr>
<td>Math.tan();</td>
<td>正切函数</td>
</tr>
<tr>
<td>Math.asin();</td>
<td>反正弦函数</td>
</tr>
<tr>
<td>Math.acos();</td>
<td>反余弦函数</td>
</tr>
<tr>
<td>Math.atan();</td>
<td>反正切函数</td>
</tr>
<tr>
<td>Math.toRadians();</td>
<td>将角度转换为弧度</td>
</tr>
<tr>
<td>Math.toDegrees();</td>
<td>将弧度转换角度</td>
</tr>
<tr>
<td>Math.exp();</td>
<td>求e的任意次方</td>
</tr>
<tr>
<td>Math.log();</td>
<td>自然对数</td>
</tr>
<tr>
<td>Math.log10();</td>
<td>以10为底的对数</td>
</tr>
<tr>
<td>Math.sqrt();</td>
<td>平方根</td>
</tr>
<tr>
<td>Math.cbrt();</td>
<td>立方根</td>
</tr>
<tr>
<td>Math.IEEEremainder();</td>
<td>求余</td>
</tr>
<tr>
<td>Math.ceil();</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.floor();</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.rint();</td>
<td>返回最接近该值的那个整数，如果存在两个这样的整数，则返回其中的偶数</td>
</tr>
<tr>
<td>Math.atan2();</td>
<td>返回从 x 轴到点 (x,y) 之间的角度</td>
</tr>
<tr>
<td>Math.pow(x,y);</td>
<td>x的y次方</td>
</tr>
<tr>
<td>Math.round();</td>
<td>四舍五入</td>
</tr>
<tr>
<td>Math.random();</td>
<td>返回0，1之间的一个随机数</td>
</tr>
<tr>
<td>Math.addExact();</td>
<td>加法运算</td>
</tr>
<tr>
<td>Math.subtractExact();</td>
<td>减法运算</td>
</tr>
<tr>
<td>Math.multiplyExact();</td>
<td>乘法运算</td>
</tr>
<tr>
<td>Math.incrementExact();</td>
<td>返回参数值加一</td>
</tr>
<tr>
<td>Math.decrementExact();</td>
<td>返回参数值减一</td>
</tr>
<tr>
<td>Math.negateExact();</td>
<td>改变参数符号</td>
</tr>
<tr>
<td>Math.toIntExact();</td>
<td>求int值</td>
</tr>
<tr>
<td>Math.floorDiv();</td>
<td>第一个参数除以第二参数，然后针对结果执行floor操作，返回小于或等于商的整数</td>
</tr>
<tr>
<td>Math.floorMod();</td>
<td>对一个数的余数进行下舍入，返回给定参数最大的整数，该整数小于或等给定的参数</td>
</tr>
<tr>
<td>Math.abs();</td>
<td>返回绝对值</td>
</tr>
<tr>
<td>Math.max();</td>
<td>求两数中最大</td>
</tr>
<tr>
<td>Math.min();</td>
<td>求两数中最小</td>
</tr>
<tr>
<td>Math.ulp();</td>
<td>返回参数的ulp大小</td>
</tr>
<tr>
<td>Math.signum();</td>
<td>符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0。</td>
</tr>
<tr>
<td>Math.sinh();</td>
<td>双曲正弦值</td>
</tr>
<tr>
<td>Math.cosh();</td>
<td>双曲余弦值</td>
</tr>
<tr>
<td>Math.tanh();</td>
<td>双曲正切值</td>
</tr>
<tr>
<td>Math.hypot();</td>
<td>返回 sqrt(x2次方 +y2次方) 没有中间溢或下溢</td>
</tr>
<tr>
<td>Math.expm1();</td>
<td>返回 Ex次方 - 1, 其中 x 是该函数的参数, E 是自然对数的底数</td>
</tr>
<tr>
<td>Math.log1p();</td>
<td>返回参数与 1 之和的自然对数</td>
</tr>
<tr>
<td>Math.copySign();</td>
<td>符号赋值，返回带有第二个浮点数符号的第一个浮点参数</td>
</tr>
<tr>
<td>Math.getExponent();</td>
<td>返回参数的无偏指数</td>
</tr>
<tr>
<td>Math.nextAfter();</td>
<td>返回第一个参数和第二个参数之间与第一个参数相邻的浮点数</td>
</tr>
<tr>
<td>Math.nextUp();</td>
<td>返回比目标数略大的浮点数</td>
</tr>
<tr>
<td>Math.nextDown();</td>
<td>返回参数直接较低的值</td>
</tr>
<tr>
<td>Math.scalb();</td>
<td>返回 d x 2(scaleFactor次方)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-自定义键盘</title>
    <url>/2021/02/25/android-keyboard/</url>
    <content><![CDATA[<p>在开发中，可能会有一些对于键盘的自定义，不建议直接使用PopWindow或者Dialog，可以尝试一下隐藏掉系统的键盘，我们自定义一个。</p>
<p>大体上分为一下几步：</p>
<ul>
<li>编写键盘上展示内容的xml文件</li>
<li>创建键盘Util使用类</li>
<li>使用</li>
</ul>
<span id="more"></span>

<h3 id="编写xml文件"><a href="#编写xml文件" class="headerlink" title="编写xml文件"></a>编写xml文件</h3><p>在res目录下创建一个xml文件夹，然后新建一个.xml文件，这个文件用来标识键盘上要显示的内容，以及编码。先放上示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Keyboard</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:horizontalGap</span>=<span class="string">&quot;2dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:keyHeight</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:verticalGap</span>=<span class="string">&quot;2dp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyEdgeFlags</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        &lt;<span class="attr">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;6&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;7&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;7&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;8&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Key</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:codes</span>=<span class="string">&quot;9&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyEdgeFlags</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:keyLabel</span>=<span class="string">&quot;9&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Keyboard</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><Keyboard>标签中的android:keyHeight和android:keyWidth属性，可以使用百分比赋值。<br>标签属性：<br>属性 说明<br>keyLabel 按键显示的内容<br>keyIcon 按键显示的图标内容<br>keyWidth 按键的宽度<br>keyHeight 按键的高度<br>horizontalGap 代表按键前的间隙水平方向上的<br>isSticky 按键是否是sticky的，就像shift 键 具有两种状态<br>isModifier 按键是不是功能键<br>keyOutputText 指定按键输出的内容是字符串<br>isRepeatable 按键是可重复的，如果长按键可以触发重复按键事件则为true，else为false<br>keyEdgeFlags 指定按键的对齐指令，取值为left或者right<br>codes 指这个键代表的字符的unicode</p>
<p>常用的codes值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EDGE_LEFT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EDGE_RIGHT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EDGE_TOP</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EDGE_BOTTOM</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_SHIFT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_MODE_CHANGE</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_CANCEL</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_DONE</span> <span class="operator">=</span> -<span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_DELETE</span> <span class="operator">=</span> -<span class="number">5</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEYCODE_ALT</span> <span class="operator">=</span> -<span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>还需要一个布局xml文件来显示每个按键的预览图，在layout文件夹中创建即可，示例代码key_preview.xml：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#FF0000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建Util帮助类"><a href="#创建Util帮助类" class="headerlink" title="创建Util帮助类"></a>创建Util帮助类</h3><p>在这个类中，主要对KeyboardView和Keyboard进行一些配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLetterKeyboard</span><span class="params">()</span> &#123;</span><br><span class="line">    mKeyboard = <span class="literal">null</span>;</span><br><span class="line">    mKeyboard = <span class="keyword">new</span> <span class="title class_">Keyboard</span>(mActivity, R.xml.letters_kb);</span><br><span class="line">    mKeyboardView.setKeyboard(mKeyboard);</span><br><span class="line">    mKeyboardView.setOnKeyboardActionListener(mListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把自定义的内容xml文件加载进入Keyboard中，再放入KeyboardView中，监听setOnKeyboardActionListener方法，获取键盘上按键的点击监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键盘监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> KeyboardView.<span class="type">OnKeyboardActionListener</span> <span class="variable">mListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KeyboardView</span>.OnKeyboardActionListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> primaryCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPress</span><span class="params">(<span class="type">int</span> primaryCode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 松开触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> primaryCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRelease</span><span class="params">(<span class="type">int</span> primaryCode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 松开触发，在OnRelease之前触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> primaryCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyCodes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onKey</span><span class="params">(<span class="type">int</span> primaryCode, <span class="type">int</span>[] keyCodes)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">editStr</span> <span class="operator">=</span> mEditText.getText().toString();</span><br><span class="line">  					<span class="comment">//这里的primaryCode就是xml文件中设置的code，用来区别按键执行不同的功能</span></span><br><span class="line">            <span class="keyword">if</span> (primaryCode == -<span class="number">5</span>) &#123;</span><br><span class="line">      					<span class="comment">//是否显示预览图</span></span><br><span class="line">                mKeyboardView.setPreviewEnabled(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (editStr.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    mEditText.setText(editStr.substring(<span class="number">0</span>, editStr.length() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (primaryCode == -<span class="number">3</span>) &#123;</span><br><span class="line">                mKeyboardView.setPreviewEnabled(<span class="literal">false</span>);</span><br><span class="line">								<span class="comment">//点击完成隐藏掉键盘</span></span><br><span class="line">                hideKeyboard();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mKeyboardView.setPreviewEnabled(<span class="literal">true</span>);</span><br><span class="line">      					<span class="comment">//通过primaryCode获取按键的值</span></span><br><span class="line">                mEditText.setText(editStr + mKeyboard.getKeys().get(primaryCode).label.toString());</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义xml的keyOutputText的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onText</span><span class="params">(CharSequence text)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左滑动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swipeLeft</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右滑动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swipeRight</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下滑动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swipeDown</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上滑动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swipeUp</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置完成，展示出来就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showEditKeyboard</span><span class="params">(EditText view)</span> &#123;</span><br><span class="line">		<span class="comment">//添加一个展示的动画</span></span><br><span class="line">    <span class="type">TranslateAnimation</span> <span class="variable">animation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TranslateAnimation</span>(</span><br><span class="line">            Animation.RELATIVE_TO_PARENT, <span class="number">0.0f</span>, Animation.RELATIVE_TO_PARENT, <span class="number">0.0f</span>,</span><br><span class="line">            Animation.RELATIVE_TO_PARENT, <span class="number">1.0f</span>, Animation.RELATIVE_TO_PARENT, <span class="number">0.0f</span></span><br><span class="line">    );</span><br><span class="line">    animation.setDuration(<span class="number">500</span>);</span><br><span class="line">    mKeyboardView.startAnimation(animation);</span><br><span class="line">		<span class="comment">//以防万一，先关闭掉系统键盘</span></span><br><span class="line">    hideKeyboard(view);</span><br><span class="line">    mKeyboardView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏掉自定义键盘：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hideKeyboard</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TranslateAnimation</span> <span class="variable">animation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TranslateAnimation</span>(</span><br><span class="line">            Animation.RELATIVE_TO_SELF, <span class="number">0.0f</span>, Animation.RELATIVE_TO_SELF, <span class="number">0.0f</span>,</span><br><span class="line">            Animation.RELATIVE_TO_SELF, <span class="number">0.0f</span>, Animation.RELATIVE_TO_SELF, <span class="number">1.0f</span>);</span><br><span class="line">    animation.setDuration(<span class="number">500</span>);</span><br><span class="line">    mKeyboardView.startAnimation(animation);</span><br><span class="line">    mKeyboardView.setVisibility(View.GONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，你可能会问，为什么使用的setVisibility()，我的思路是在布局中先绘制上KeyBoardView，隐藏掉，这样点击输入框的时候，就让它显示出来。来看一下布局文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/parentView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#F5DEB3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvProvince&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;京&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#FF0000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">com.jiaop.demos.keyboard.LastInputEditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/etInput&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">&quot;输入&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:letterSpacing</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:maxLength</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:maxLines</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#DEB887&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">android.inputmethodservice.KeyboardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/kvShow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:keyBackground</span>=<span class="string">&quot;@color/colorAccent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:keyPreviewLayout</span>=<span class="string">&quot;@layout/key_preview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:keyTextColor</span>=<span class="string">&quot;#8A2BE2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:keyTextSize</span>=<span class="string">&quot;14sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用起来就很简单了，只需要先实例化Util类，依次调用键盘的初始化和显示或隐藏就行了，不过在键盘中设置了“完成”按钮，所以点击“完成”即可关闭掉自定义键盘。</p>
<p>这只不过是很简单的自定义键盘，如果像银行那种安全性键盘，我想应该一些字码安全处理，有了基础，再根据需求深度开发不也是手到擒来的么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> KeyboardUtil keyboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ButterKnife.bind(<span class="built_in">this</span>);</span><br><span class="line">    keyboardUtil = KeyboardUtil.getInstance();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示键盘</span></span><br><span class="line"><span class="meta">@OnClick(R.id.tvProvince)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tvProvince</span><span class="params">()</span> &#123;</span><br><span class="line">    keyboardUtil.initTextViewFeatures(<span class="built_in">this</span>, tvProvince, kvShow);</span><br><span class="line">    keyboardUtil.showTextKeyboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-MotionLayout管理运动和微件动画</title>
    <url>/2021/03/02/android-motionLayout/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>MotionLayout</code>是一种布局类型，是<code>ConstraintLayout</code> 库的一部分，实现了运动形式的动画，缩小了布局转换与复杂运动处理之间的差距，同时在<code>属性动画框架</code>和 <code>CoordinatorLayout</code>之间提供了各种功能。</p>
<p><code>MotionLayout</code>完全可以使用xml文件来描述任何转换和动画，无论多么复杂。值得注意的是，<code>MotionLayout</code> 仅适用于其直接子级，不支持嵌套布局层次结构或 <code>Activity </code>转换。</p>
<p>项目中要做一个仿携程的城市交换动画，一开始使用属性动画写起来很是麻烦，后来就用了<code>MotionLayout</code>，虽然还是有些瑕疵，不过逻辑处理上清晰了很多。</p>
<span id="more"></span>

<h4 id="声明依赖项"><a href="#声明依赖项" class="headerlink" title="声明依赖项"></a>声明依赖项</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span></span><br></pre></td></tr></table></figure>

<p>引入版本需要在2.0以上，旧版本不支持。</p>
<h4 id="绘制页面布局xml"><a href="#绘制页面布局xml" class="headerlink" title="绘制页面布局xml"></a>绘制页面布局xml</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/motionLayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutDescription</span>=<span class="string">&quot;@xml/scene1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showPaths</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;北京站&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;上海站&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>app:layoutDescription</code>：</p>
<blockquote>
<p>引用的是一个<code>MotionScene</code>，它是一个<code>xml</code>资源文件，用来描述所有的运动。为了将布局信息与运动描述分开，每个<code>MotionLayout</code>都要引用一个单独的<code>MotionScene</code>。注意，<code>MotionScene </code>中的定义优先于 <code>MotionLayout</code> 中的任何类似定义。</p>
</blockquote>
<p><code>app:showPaths</code>：</p>
<blockquote>
<p>表示在运动进行时是否显示运动路径。此属性的默认值为 <code>false</code>。</p>
</blockquote>
<p><code>app:applyMotionScene=&quot;boolean</code>：</p>
<blockquote>
<p>表示是否应用 MotionScene。此属性的默认值为 <code>true</code>。</p>
</blockquote>
<p><code>app:progress=&quot;float</code>：</p>
<blockquote>
<p>可让您明确指定转换进度。您可以使用从 <code>0</code>（转换开始）到 <code>1</code>（转换结束）之间的任意浮点值。</p>
</blockquote>
<p><code>app:currentState=&quot;reference</code>：</p>
<blockquote>
<p>可让您指定具体的 <code>ConstraintSet</code>。</p>
</blockquote>
<p><code>app:motionDebug</code>：</p>
<blockquote>
<p>可让您显示与运动有关的其他调试信息。可能的值为“SHOW_PROGRESS”、“SHOW_PATH”或“SHOW_ALL”。</p>
</blockquote>
<h4 id="配置MotionScene描述文件"><a href="#配置MotionScene描述文件" class="headerlink" title="配置MotionScene描述文件"></a>配置MotionScene描述文件</h4><p>在<code>res</code>下创建<code>xml</code>包，新建<code>scene.xml</code>描述文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MotionScene</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:motion</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--运动的基本定义</span></span><br><span class="line"><span class="comment">        motion:constraintSetStart 和 motion:constraintSetEnd：运动的端点。</span></span><br><span class="line"><span class="comment">        这些端点在 MotionScene 后面的 &lt;ConstraintSet&gt; 元素中定义。</span></span><br><span class="line"><span class="comment">        motion:duration：完成运动所需的毫秒数。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">motion:constraintSetEnd</span>=<span class="string">&quot;@+id/end&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">motion:constraintSetStart</span>=<span class="string">&quot;@+id/start&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">motion:duration</span>=<span class="string">&quot;500&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--轻触控制运动</span></span><br><span class="line"><span class="comment">            motion:touchAnchorId：可以滑动并拖动的视图。</span></span><br><span class="line"><span class="comment">            motion:touchAnchorSide：表示我们从右侧拖动视图。</span></span><br><span class="line"><span class="comment">            motion:dragDirection：拖动的进度方向。例如，motion:dragDirection=&quot;dragRight&quot; 表示当您向右拖动时，进度会增加。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">OnSwipe</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:touchAnchorId</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:touchAnchorSide</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:dragDirection</span>=<span class="string">&quot;dragRight&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义描述运动的各种限制条件的位置。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/start&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--android:id：需要和布局文件中MotionLayout里面子组件的id一致，一一对应。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--自定义属性，为不仅仅与位置相关的属性或 View 属性指定转换。</span></span><br><span class="line"><span class="comment">            这个标签也可以用在Constraint标签里面</span></span><br><span class="line"><span class="comment">            motion:attributeName：是必需属性，并且必须与具有 getter 和 setter 方法的对象匹配。getter 和 setter 与特定模式非常匹配。</span></span><br><span class="line"><span class="comment">            此外，您必须提供的另一个属性基于值类型。从以下支持的类型中选择：</span></span><br><span class="line"><span class="comment">            motion:customColorValue 适用于颜色</span></span><br><span class="line"><span class="comment">            motion:customIntegerValue 适用于整数</span></span><br><span class="line"><span class="comment">            motion:customFloatValue 适用于浮点值</span></span><br><span class="line"><span class="comment">            motion:customStringValue 适用于字符串</span></span><br><span class="line"><span class="comment">            motion:customDimension 适用于尺寸</span></span><br><span class="line"><span class="comment">            motion:customBoolean 适用于布尔值</span></span><br><span class="line"><span class="comment">            注意，在指定自定义属性时，您必须定义开始和结束 &lt;ConstraintSet&gt; 元素中的端点值。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CustomAttribute</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:attributeName</span>=<span class="string">&quot;backgroundColor&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:customColorValue</span>=<span class="string">&quot;#D81B60&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/end&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">motion:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">MotionScene</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="KeyFrameSet关键帧"><a href="#KeyFrameSet关键帧" class="headerlink" title="KeyFrameSet关键帧"></a>KeyFrameSet关键帧</h3><p>这个标签可以改变我们动画过程中某个关键帧的位置以及状态信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetEnd</span>=<span class="string">&quot;@id/end&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetStart</span>=<span class="string">&quot;@id/start&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">KeyFrameSet</span>&gt;</span></span><br><span class="line">          </span><br><span class="line">            <span class="tag">&lt;<span class="name">KeyPosition</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:framePosition</span>=<span class="string">&quot;50&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:keyPositionType</span>=<span class="string">&quot;parentRelative&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:motionTarget</span>=<span class="string">&quot;@id/windmill&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:percentY</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">&lt;!--前半段的动画效果：逆时针旋转一圈，同时放大一倍--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">KeyAttribute</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:framePosition</span>=<span class="string">&quot;50&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:motionTarget</span>=<span class="string">&quot;@id/windmill&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:rotation</span>=<span class="string">&quot;-360&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:scaleX</span>=<span class="string">&quot;2.0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:scaleY</span>=<span class="string">&quot;2.0&quot;</span> /&gt;</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">&lt;!--后半段的动画效果：逆时针旋转一圈，同时变回原样--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">KeyAttribute</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:framePosition</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:motionTarget</span>=<span class="string">&quot;@id/windmill&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:rotation</span>=<span class="string">&quot;-720&quot;</span> /&gt;</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">&lt;!--延迟动画——0-85过程中将透明度一直维持在0.0--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">KeyAttribute</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:framePosition</span>=<span class="string">&quot;85&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:motionTarget</span>=<span class="string">&quot;@id/tipText&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:alpha</span>=<span class="string">&quot;0.0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">KeyFrameSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>KeyPosition</code>和<code>KeyAttribute</code>：用来设置动画某个位置的关键帧，进而为某段动画指定所期望的效果。</p>
<p><code>KeyPosition</code>用于指定动画某个关键帧的位置信息。</p>
<p><code>KeyAttribute</code> 则用来描述动画某关键帧的属性配置（如：透明度、缩放、旋转等）。</p>
<h4 id="页面中使用"><a href="#页面中使用" class="headerlink" title="页面中使用"></a>页面中使用</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始动画，起始点和终点</span></span><br><span class="line">motionLayout?.transitionToStart()</span><br><span class="line">motionLayout?.transitionToEnd()</span><br><span class="line"></span><br><span class="line">motionLayout?.setTransitionListener(<span class="keyword">object</span> : MotionLayout.TransitionListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransitionCompleted</span><span class="params">(p0: <span class="type">MotionLayout</span>?, p1: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">              <span class="comment">//	动画完全执行完毕</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransitionStarted</span><span class="params">(p0: <span class="type">MotionLayout</span>?, p1: <span class="type">Int</span>, p2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">              <span class="comment">//动画开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransitionChange</span><span class="params">(p0: <span class="type">MotionLayout</span>?, p1: <span class="type">Int</span>, p2: <span class="type">Int</span>, p3: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">              <span class="comment">//动画改变过程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransitionTrigger</span><span class="params">(p0: <span class="type">MotionLayout</span>?, p1: <span class="type">Int</span>, p2: <span class="type">Boolean</span>, p3: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">              <span class="comment">//动画触发时监听</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>更多事例可以查看<a href="https://developer.android.google.cn/training/constraint-layout/motionlayout/examples">MotionLayout 示例</a>，官方已经写好了，以提供参考。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p><code>MotionLayout</code>解决了我们绘制动画的复杂性，减少了相当多的计算绘制代码，但是也不能说就一定要用它，视情况和需求而定。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity的启动模式</title>
    <url>/2021/05/27/android-launch-mode/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Activity</code>的启动模式，在面试中提问到的几率很高，以此梳理一下知识点。</p>
<span id="more"></span>

<h4 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h4><p><code>Android</code>采用任务栈的方式管理<code>Activity</code>的实例，当一个应用启动时，<code>Android</code>就会创建一个任务栈。任务栈类似于一个容器，每次存放一个<code>Activity</code>时，满足“先进后出（First-In&#x2F;Last-out）”的原则。先加入的<code>Activity</code>实例将会处于底部，后加入的<code>Activity</code>实例会依次处于栈的上面。堆栈中存放的<code>Activity</code>实例顺序永远不会重新排列，只会被送入和退出。</p>
<p>启动模式简单地说就是<code>Activity</code>启动时的策略，告诉堆栈将如何管理里面的实例。</p>
<h4 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h4><h5 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h5><p>标准模式。默认启动模式。每启动一个<code>Activity</code>，就会创建一个新的实例，并将处于堆栈的栈顶位置。</p>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><p>栈顶复用模式。如果当前实例已经存在于栈顶，堆栈将直接使用它，不会再重新创建新的实例。系统将调用<code>onNewIntent()</code>方法将<code>intent</code>转送给该实例。</p>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><p>栈内复用模式。每次启动该<code>Activity</code>时，系统首先会检查堆栈中是否存在该<code>Activity</code>的实例，如果发现已经存在则直接使用该实例，并将当前<code>Activity</code>之上的所有<code>Activity</code>出栈，如果没有发现则创建一个新的实例。 系统将调用<code>onNewIntent()</code>方法将<code>intent</code>转送给该实例。</p>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><p>单实例模式。<code>singleTask</code>的增强版，具有它的所有特性。如果该<code>Activity</code>实例不存在，系统将开启一个新的堆栈，存放这个实例，并保证不再有其他<code>Activity</code>实例进入。如果<code>Activity</code>实例已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该<code>Activity</code>所有的任务栈转到前台，从而使该<code>Activity</code>显示出来。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>standard：适用于大部分场景。</p>
<p>singleTop：适合接收通知启动的内容显示页面。</p>
<p>singleTask：适合作为程序入口点。</p>
<p>singleInstance：适合需要与程序分离开的页面。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li><p>在 Manifest.xml中指定Activity启动模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.activity.Activity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Intent</code>标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line"><span class="comment">//作用是为Activity指定 “SingleTask”启动模式。跟在AndroidMainfest.xml指定效果同样。</span></span><br><span class="line"><span class="comment">//FLAG_ACTIVITY_SINGLE_TOP</span></span><br><span class="line"><span class="comment">//作用是为Activity指定 “SingleTop”启动模式，跟在AndroidMainfest.xml指定效果同样。</span></span><br><span class="line"><span class="comment">//FLAG_ACTIVITY_CLEAN_TOP</span></span><br><span class="line"><span class="comment">//具有此标记位的Activity，启动时会将与该Activity在同一任务栈的其他Activity出栈。一般与SingleTask启动模式一起出现。它会完毕SingleTask的作用。但事实上SingleTask启动模式默认具有此标记位的作用</span></span><br><span class="line"><span class="comment">//FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</span></span><br><span class="line"><span class="comment">//具有此标记位的Activity不会出如今历史Activity的列表中，使用场景：当某些情况下我们不希望用户通过历史列表回到Activity时，此标记位便体现了它的效果。它等同于在xml中指定Activity的属性：</span></span><br><span class="line"><span class="comment">//android:excludeFromRecents=“trure”</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClass(context, MainActivity.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-关于Activity生命周期的理解</title>
    <url>/2021/05/24/android-life-cycle/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在重构支付模块时，测试说一直跳转不到支付结果页面，最后发现我们是在<code>onRestart()</code>里面写的支付回调接口，但是那个小米的测试机，真的就是不走<code>onRestart()</code>方法啊！！奇怪的知识又增加了，这个到现在我也没搞明白为什么……也好，再次熟悉一下Activity的生命周期吧，毕竟面试问的最多的也是这个。</p>
<span id="more"></span>

<h4 id="Activity生命周期的简化图示"><a href="#Activity生命周期的简化图示" class="headerlink" title="Activity生命周期的简化图示"></a>Activity生命周期的简化图示</h4><p><img data-src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png"></p>
<p>惯例先看这张经典的流程图。</p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h6 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h6><p>在<code>Activity</code>首次创建时触发，<code>Activity</code>会在创建后进入“已创建”的状态。并且只会发生一次。应当在此时完成<code>Activity</code>中的一些初始化操作。</p>
<p>参数：<code>savedInstanceState: Bundle</code>：包含<code>Activity</code>先前保存状态的<code>Bundle</code>对象，如果<code>Activity</code>此前未曾存在，该对象值为<code>null</code>。与之对应的方法为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="comment">//获取保存的状态值</span></span><br><span class="line">    <span class="keyword">val</span> gameState = savedInstanceState?.getString(GAME_STATE_KEY)</span><br><span class="line">    setContentView(R.layout.main_activity)</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRestoreInstanceState</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">//此方法在onStart()完成后执行，根据不同业务场景按需调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当活动可能被临时破坏时调用，在此处保存实例状态</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    outState?.run &#123;</span><br><span class="line">        putString(GAME_STATE_KEY, gameState)</span><br><span class="line">        putString(TEXT_VIEW_KEY, textView.text.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h6><p>在<code>onCreate()</code>之后执行，<code>Activity</code>处于“已开始”状态，此时<code>Activity</code>对用户是可见状态，应用会为<code>Activity</code>进入前台并支持互动做准备，可以在<code>onStart()</code>方法中，初始化维护界面的代码。</p>
<h6 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h6><p><code>Activity</code>进入“已恢复”状态，并来到前台，此时应用与用户处于互动状态。应用会一直保持这种状态。<code>Activity</code>也一定位于返回栈的栈顶并处于运行状态。</p>
<h6 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h6><p>调用这个方法时，说明用户将要离开当前<code>Activity</code>，<code>Activity</code>将不再位于前台，而是处于“已暂停”状态。这个函数的执行速度一定要快，不然会影响新的栈顶活动的使用。通常在此函数中将一些消耗CPU的资源释放掉，以及保存一些重要的数据。</p>
<h6 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h6><p>此时，<code>Activity</code>已进入“已停止”状态，<code>Activity</code>不再对用户可见，新的<code>Activity</code>已经覆盖屏幕。这个函数中，应释放或调整在应用对用户不可见时的无用资源，例如：暂停动画效果等。</p>
<h6 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h6><p><code>Activity</code>销毁状态调用，此时<code>Activity</code>被用户彻底关闭，或者调用了<code>finish()</code>方法，或者由于配置变更，例如设备旋转、多窗口模式，系统暂时销毁<code>Activity</code>。</p>
<h6 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h6><p><code>Activity</code>由停止状态变为运行状态之前调用，<code>Activity</code>重启。</p>
<h4 id="各种场景下调用顺序"><a href="#各种场景下调用顺序" class="headerlink" title="各种场景下调用顺序"></a>各种场景下调用顺序</h4><ul>
<li><h6 id="Activity跳转到下一个Activity"><a href="#Activity跳转到下一个Activity" class="headerlink" title="Activity跳转到下一个Activity"></a><code>Activity</code>跳转到下一个<code>Activity</code></h6></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$:MainActivity onCreate</span><br><span class="line">$:MainActivity onStart</span><br><span class="line">$:MainActivity onResume</span><br><span class="line">$:MainActivity onPause</span><br><span class="line">$:SecondActivity onCreate</span><br><span class="line">$:SecondActivity onStart</span><br><span class="line">$:SecondActivity onResume</span><br><span class="line">$:MainActivity onStop</span><br></pre></td></tr></table></figure>

<p>然后从第二个<code>Activity</code>返回到之前的<code>Activity</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$:SecondActivity onPause</span><br><span class="line">$:MainActivity onRestart</span><br><span class="line">$:MainActivity onStart</span><br><span class="line">$:MainActivity onResume</span><br><span class="line">$:SecondActivity onStop</span><br><span class="line">$:SecondActivity onDestroy</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Activity中打开Dialog样式的Activity"><a href="#Activity中打开Dialog样式的Activity" class="headerlink" title="Activity中打开Dialog样式的Activity"></a><code>Activity</code>中打开<code>Dialog</code>样式的<code>Activity</code></h6></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$:MainActivity onCreate</span><br><span class="line">$:MainActivity onStart</span><br><span class="line">$:MainActivity onResume</span><br><span class="line">$:MainActivity onPause</span><br><span class="line">$:SecondActivity onCreate</span><br><span class="line">$:SecondActivity onStart</span><br><span class="line">$:SecondActivity onResume</span><br></pre></td></tr></table></figure>

<p>关闭<code>Dialog</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$:SecondActivity onPause</span><br><span class="line">$:MainActivity onResume</span><br><span class="line">$:SecondActivity onStop</span><br><span class="line">$:SecondActivity onDestroy</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="Activity翻转屏幕（会重新创建）"><a href="#Activity翻转屏幕（会重新创建）" class="headerlink" title="Activity翻转屏幕（会重新创建）"></a><code>Activity</code>翻转屏幕（会重新创建）</h6></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">$:MainActivity onCreate</span><br><span class="line">$:MainActivity onStart</span><br><span class="line">$:MainActivity onResume</span><br><span class="line">$:MainActivity onPause</span><br><span class="line">$:MainActivity onStop</span><br><span class="line">$:MainActivity onDestroy</span><br><span class="line">$:MainActivity onCreate</span><br><span class="line">$:MainActivity onStart</span><br><span class="line">$:MainActivity onResume</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-使用前台服务</title>
    <url>/2021/03/03/android-notification-service/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>项目中涉及到了蓝牙设备的开发，需要开启一个后台服务实时监听数据变化，在进程保活这块和同事探讨了很久，然后发现课本里面有讲啊《第一行代码- Android》。产品需求也不并不是很严，就考虑使用前台服务确保进程的保活，起码不会被kill了。</p>
<span id="more"></span>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h6 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">val</span> channel = NotificationChannel(</span><br><span class="line">                <span class="string">&quot;my_service&quot;</span>,</span><br><span class="line">                <span class="string">&quot;前台服务通知&quot;</span>,</span><br><span class="line">                NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">            )</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">&quot;my_service&quot;</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;这是标题&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;这是内容&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, R.mipmap.ic_launcher))</span><br><span class="line">            .setContentIntent(pi)</span><br><span class="line">            .build()</span><br><span class="line">        startForeground(<span class="number">1</span>, notification)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> START_STICKY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="配置清单文件AndroidManifest-xml"><a href="#配置清单文件AndroidManifest-xml" class="headerlink" title="配置清单文件AndroidManifest.xml"></a>配置清单文件AndroidManifest.xml</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">				<span class="attr">...</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">				...</span><br><span class="line">  			</span><br><span class="line">				<span class="comment">&lt;!--android:enabled：表示是否启用这个服务</span></span><br><span class="line"><span class="comment">            android:exported：表示是否允许除了当前程序之外的其他程序访问这个服务</span></span><br><span class="line"><span class="comment">            android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</span></span><br><span class="line"><span class="comment">            android:isolatedProcess：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startService(Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-RecyclerView的SelectionTracker选择器使用</title>
    <url>/2021/02/26/android-selection-tracker/</url>
    <content><![CDATA[<p>浏览Android开发者文档的时候，发现Android Jetpack里面有一个<a href="https://developer.android.google.cn/reference/androidx/recyclerview/selection/package-summary"><code>recyclerview-selection</code></a>库，官方是这样介绍的：</p>
<blockquote>
<p>用户可以通过触摸或鼠标输入来选择 <code>RecyclerView</code> 列表中的项。您仍然可以控制所选项的视觉呈现效果。您也仍然可以控制用于约束选择行为的政策，例如符合入选条件的项以及可以选择的项数。</p>
</blockquote>
<p>其实，就是为了方便处理RecyclerView的Item选择问题，并且可以在设备配置改变的时候保存已选择的数据，重新创建页面的时候再次加载，省去了我们自己对这部分的操作；同时通过观察者模式提供了item点击监听、长按订阅功能。</p>
<span id="more"></span>

<p>我在使用过程中，发现了一个问题，目前还没有找到解决方式，在选中状态下，Item布局里面的子View点击事件会没有响应，点击事件一直是整个Item的，如果哪位大佬有解决方法，请联系我。</p>
<p>本文Github项目：</p>
<p><a href="https://github.com/hijiaopeng/AndroidSelectionTracker"><code>hijiaopeng/AndroidSelectionTracker</code></a></p>
<p>下面就聊聊如何使用recyclerview-selection这个库。</p>
<h6 id="引入recyclerview-selection库"><a href="#引入recyclerview-selection库" class="headerlink" title="引入recyclerview-selection库"></a>引入recyclerview-selection库</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入recyclerview库，请使用最新版本</span></span><br><span class="line">implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.2.0-alpha06&#x27;</span></span><br><span class="line"><span class="comment">// 引入recyclerview-selection库，请使用最新版本</span></span><br><span class="line">implementation <span class="string">&#x27;androidx.recyclerview:recyclerview-selection:1.1.0-rc03&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="构建ItemKeyProvider"><a href="#构建ItemKeyProvider" class="headerlink" title="构建ItemKeyProvider"></a>构建ItemKeyProvider</h6><p>选择一个key类型来构建KeyProvider，recyclerview-selection库只支持三种类型：</p>
<p>String：基于字符串的稳定标识符；</p>
<p>Long：当RecyclerView的long stable Id已经在使用时，使用long，但是会有一些限制，在运行时访问一个稳定的id会被限定。需要确保id是稳定的，将<code>setHasStableIds</code>设置为true，将该选项设置为true只会告诉RecyclerView数据集中的每个项目都可以用Long类型的唯一标识符表示；</p>
<p>Parcelable：任何Parcelable都可以用作selection的key，如果view中的内容与稳定的<code>content:// uri</code>相关联，就是用uri作为key的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里选择Parcelable类型，整个Item对象作为key。</span></span><br><span class="line"><span class="comment"> * ItemKeyProvider的参数：</span></span><br><span class="line"><span class="comment"> * SCOPE_CACHED：提供对基于视图中最近绑定的项目的缓存数据的访问。使用此提供程序将导致功能集减少，因为一些功能（例如SHIFT +单击范围选择和波段选择）取决于映射访问。</span></span><br><span class="line"><span class="comment"> * SCOPE_MAPPED：提供对所有数据的访问，无论是否绑定到视图。具有此访问类型的密钥提供者享受对增强功能的支持，例如：SHIFT +单击范围选择和频段选择。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyKeyProvider</span>(<span class="keyword">private</span> val adapter: ItemAdapter) :</span><br><span class="line">    ItemKeyProvider&lt;Person&gt;(SCOPE_CACHED)&#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getKey</span><span class="params">(position: Int)</span>: Person = adapter.getItem(position)</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getPosition</span><span class="params">(key: Person)</span>: Int = adapter.getPosition(key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="构建ItemDetailsLookup"><a href="#构建ItemDetailsLookup" class="headerlink" title="构建ItemDetailsLookup"></a>构建ItemDetailsLookup</h6><p>ItemDetailsLookup接口可以接受RecyclerView的Item上发生的MotionEvent事件，我们需要实现其<code>getItemDetails()</code>方法，通过ReyclerView的<code>findChildView(int,int)</code>方法来判断具体touch的是哪一个Item，强转成我们的ViewHolder类型，调用我们<code>RecyclerView.ViewHolder</code>中的方法来返回一个ItemDetails实例，返回实例的方法是我们自己添加的，ViewHolder中并没有该抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLookup</span>(<span class="keyword">private</span> val recyclerView: RecyclerView) :</span><br><span class="line">    ItemDetailsLookup&lt;Person&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getItemDetails</span><span class="params">(e: MotionEvent)</span>: ItemDetails&lt;Person&gt;? &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recyclerView.findChildViewUnder(e.x, e.y)</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (recyclerView.getChildViewHolder(view) as ItemAdapter.ItemViewHolder).itemDetails</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是返回ItemDetails实例的方法，写在Adapter适配器ViewHolder中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val itemDetails: ItemDetailsLookup.ItemDetails&lt;Person&gt;</span><br><span class="line">            <span class="title function_">get</span><span class="params">()</span> = MyItemDetails(absoluteAdapterPosition, mList[absoluteAdapterPosition])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyItemDetails</span>(<span class="keyword">private</span> val position: Int, <span class="keyword">private</span> val item: Person) :</span><br><span class="line">    ItemDetailsLookup.ItemDetails&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getPosition</span><span class="params">()</span>: Int &#123;</span><br><span class="line">        <span class="keyword">return</span> position</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getSelectionKey</span><span class="params">()</span>: Person &#123;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="构建Adapter"><a href="#构建Adapter" class="headerlink" title="构建Adapter"></a>构建Adapter</h6><p>适配器中，我们需要重写几个方法，并创建一个SelectionTracker对象，用来接收外部SelectionTracker对象。ViewHolder可以考虑单独写出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> val mList: List&lt;Person&gt;</span><br><span class="line">) :</span><br><span class="line">    RecyclerView.Adapter&lt;ItemAdapter.ItemViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mSelectionTracker: SelectionTracker&lt;Person&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreateViewHolder</span><span class="params">(parent: ViewGroup, viewType: Int)</span>: ItemViewHolder &#123;</span><br><span class="line">        val view: View = LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.list_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ItemViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onBindViewHolder</span><span class="params">(holder: ItemViewHolder, position: Int)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">item</span> <span class="operator">=</span> mList[position]</span><br><span class="line">        mSelectionTracker?.isSelected(item)?.let &#123; holder.bind(item, it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getItemCount</span><span class="params">()</span>: Int &#123;</span><br><span class="line">        <span class="keyword">return</span> mList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getItemId</span><span class="params">(position: Int)</span>: Long &#123;</span><br><span class="line">        <span class="keyword">return</span> mList[position].hashCode().toLong()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">getItem</span><span class="params">(position: Int)</span>: Person = mList[position]</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">getPosition</span><span class="params">(person: Person)</span>: Int = mList.indexOf(person)</span><br><span class="line"></span><br><span class="line">    inner <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> val tvItemId: TextView = itemView.findViewById(R.id.tvItemId)</span><br><span class="line">        <span class="keyword">private</span> val tvItemName: TextView = itemView.findViewById(R.id.tvItemName)</span><br><span class="line"></span><br><span class="line">        fun <span class="title function_">bind</span><span class="params">(item: Person?, isSelected: Boolean)</span> &#123;</span><br><span class="line">          	<span class="comment">//这里为了解决只能长按触发选择的机制</span></span><br><span class="line">          	<span class="comment">//判断SelectionTracker中没有选中项时，手动将第一个Item添加进去</span></span><br><span class="line">            itemView.setOnClickListener &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSelectionTracker?.selection?.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    mSelectionTracker?.select(item!!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tvItemId.text = item?.id</span><br><span class="line">            tvItemName.text = item?.name</span><br><span class="line">          	<span class="comment">//判断是否选中</span></span><br><span class="line">            <span class="keyword">if</span> (isSelected)</span><br><span class="line">                tvItemName.setTextColor(Color.parseColor(<span class="string">&quot;#000000&quot;</span>))</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tvItemName.setTextColor(Color.parseColor(<span class="string">&quot;#de1c31&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val itemDetails: ItemDetailsLookup.ItemDetails&lt;Person&gt;</span><br><span class="line">            <span class="title function_">get</span><span class="params">()</span> = MyItemDetails(absoluteAdapterPosition, mList[absoluteAdapterPosition])</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="构建Activity里面的使用"><a href="#构建Activity里面的使用" class="headerlink" title="构建Activity里面的使用"></a>构建Activity里面的使用</h6><p>准备工作完成，看看在UI界面层如何调用吧。</p>
<p>先配置RecyclerView相关，注意需要加上<code>setHasFixedSize(true)</code>，之后创建SelectionTracker实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mSelectionTracker = SelectionTracker</span><br><span class="line">            .Builder(</span><br><span class="line">              	<span class="comment">//SelectionTracker标识</span></span><br><span class="line">                <span class="string">&quot;items-selection&quot;</span>,</span><br><span class="line">              	<span class="comment">//绑定对应的RecyclerView</span></span><br><span class="line">                recyclerView,</span><br><span class="line">              	<span class="comment">//选择键来源</span></span><br><span class="line">                MyKeyProvider(mAdapter),</span><br><span class="line">              	<span class="comment">//有关RecyclerView项目的信息源</span></span><br><span class="line">                MyLookup(recyclerView),</span><br><span class="line">              	<span class="comment">//选择状态的类型安全存储策略</span></span><br><span class="line">                StorageStrategy.createParcelableStorage(Person::class.java)</span><br><span class="line">            )</span><br><span class="line">						. ...（可以调用其他所需函数）</span><br><span class="line">						<span class="comment">//设置选择模式</span></span><br><span class="line">            .withSelectionPredicate(SelectionPredicates.createSelectAnything())</span><br><span class="line">            .build()</span><br></pre></td></tr></table></figure>

<p>SelectionPredicates下有两种模式：</p>
<blockquote>
<p>createSelectAnything()：多选</p>
<p>createSelectSingleAnything()：单选</p>
</blockquote>
<p>扩展：</p>
<p>自定义选择数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.withSelectionPredicate(object : SelectionTracker.SelectionPredicate&lt;TrainPassengerResponse&gt;() &#123;</span><br><span class="line">                    override fun <span class="title function_">canSelectMultiple</span><span class="params">()</span>: Boolean &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    override fun <span class="title function_">canSetStateForKey</span><span class="params">(key: TrainPassengerResponse, nextState: Boolean)</span>: Boolean &#123;</span><br><span class="line">                    		<span class="comment">//这里根据选择数量来做不同操作</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">if</span> (nextState &amp;&amp; mSelectionTracker?.selection?.size()!! &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="literal">false</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nextState) &#123;</span><br><span class="line">                            Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;info&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                        <span class="comment">//设置最大选择数量</span></span><br><span class="line"><span class="comment">//                        return !(nextState &amp;&amp; mPsTracker?.selection?.size()!! &gt;= 5)</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    override fun <span class="title function_">canSetStateAtPosition</span><span class="params">(position: Int, nextState: Boolean)</span>: Boolean &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>之后绑定Adapter的SelectionTracker对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mAdapter.mSelectionTracker = mSelectionTracker</span><br></pre></td></tr></table></figure>

<h6 id="配置SelectionTracker观察者监听"><a href="#配置SelectionTracker观察者监听" class="headerlink" title="配置SelectionTracker观察者监听"></a>配置SelectionTracker观察者监听</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mSelectionTracker?.addObserver(object : SelectionTracker.SelectionObserver&lt;Person&gt;() &#123;</span><br><span class="line">    override fun <span class="title function_">onSelectionChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSelectionChanged()</span><br><span class="line">        <span class="comment">//判断是否拥有选择的项</span></span><br><span class="line">        <span class="keyword">if</span> (mSelectionTracker?.hasSelection()!!) &#123;</span><br><span class="line">        		<span class="comment">//mSelectionTracker?.selection：已经选择项的集合</span></span><br><span class="line">            mSelectionTracker?.selection?.forEach &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;Selection : $it&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;Selection Count: 0&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="在生命周期中保持选择的状态"><a href="#在生命周期中保持选择的状态" class="headerlink" title="在生命周期中保持选择的状态"></a>在生命周期中保持选择的状态</h6><p>当屏幕配置改变，比如旋转屏幕时，我们已选中的item的选中状态就会消失，所以我们需要将我们的选中状态进行持久化操作，tracker为提供了相应的API方便我们持久化，将数据持久化操作与Activity的生命周期事件进行绑定。在Activity的<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>中分别调用tracker的<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>方法即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>)</span><br><span class="line">            mSelectionTracker?.onRestoreInstanceState(savedInstanceState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onSaveInstanceState</span><span class="params">(outState: Bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSaveInstanceState(outState)</span><br><span class="line">        mSelectionTracker?.onSaveInstanceState(outState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><p>在使用过程中，我发现要写很多的重复性代码，例如：LookUp类，KeyProvider类等等，连Adapter类都要针对不同页面写好几个，除了逻辑，显示，实体类不同，其他很多一样的。</p>
<p>所以我写了一个扩展函数以支持简单的使用，详情见GitHub项目中的<code>encapsulation</code>包，和<code>TestActivity</code>，<code>TestAdapter</code>类。</p>
<p>简要的介绍一下该如何使用：</p>
<ol>
<li><p>构建自己的<code>Adapter</code>类，继承<code>BaseTrackerAdapter</code>，传入布局和数据，重写<code>bind</code>方法，<code>bind</code>方法有三个参数，<code>holder</code>获取布局设置对应值和样式，<code>item</code>为数据，<code>isSelected</code>判断是否选中状态。</p>
</li>
<li><p>在页面中直接通过<code>RecyclerView</code>调用：<code>initMultipleSelectTrack()</code>多选，传入adapter，最大选择数量（可选，默认5个），超出选择数量的操作函数（可选）。<code>initSingleSelectTrack()</code>单选。</p>
</li>
<li><p>如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> track = rv_test?.initSingleSelectTrack(testAdapter)</span><br><span class="line"></span><br><span class="line">btn_show?.setOnClickListener &#123;</span><br><span class="line">	<span class="comment">//获取最后选择的数据</span></span><br><span class="line">	track?.selection?.forEach &#123;</span><br><span class="line">		Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;onCreate: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h6><p>以上描述或分析可能不是很全面，今后我会逐步完善，<a href="https://developer.android.google.cn/reference/androidx/recyclerview/selection/package-summary"><code>recyclerview-selection</code></a>库要分适当的场景进行使用，避免遇到意外坑。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio插件整理文档</title>
    <url>/2021/05/07/android-studio-plugin/</url>
    <content><![CDATA[<span id="more"></span>

<ul>
<li>SequenceDiagram：根据代码调用链路自动生成时序图</li>
<li>.ignore：生成代码提交的忽略文件</li>
<li>JSON To Kotlin Class：Json字符串转译为Kotlin数据类</li>
<li>Markdown：Markdown编辑器</li>
<li>Material Theme UI：自定义Android Studio的界面UI</li>
<li>Translation：翻译插件</li>
<li>CodeGlance：在右侧显示代码地图</li>
<li>Rainbow Brackets：彩虹括号</li>
<li>Codota：辅助开发神器，智能代码自动提示</li>
<li>AiXcoder Code Completer：代码提示补全</li>
<li>Grep Console：自定义控制台输出格式</li>
<li>HighlightBracketPair：高亮显示</li>
<li>Android Drawable Preview：预览图片资源缩略图</li>
<li>ADB Idea：ADB调试工具</li>
<li>AndroidProguardPlugin：一键生成项目混淆代码</li>
<li>folding-plugin：布局文件分组</li>
<li>Kotlin Fill Class：快速创建具有默认属性的Kotlin类</li>
<li>KDoc-er - Kotlin Doc Generator：快速生成注释</li>
<li>Lint Cleaner Plugin：删除项目中未使用的资源</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发中一些实用点</title>
    <url>/2021/05/07/android-tips/</url>
    <content><![CDATA[<span id="more"></span>

<ul>
<li><p>组合使用<merge/>（只能在布局根节点使用）、<include/>、<ViewStub/>标签，减少布局层级嵌套；</p>
</li>
<li><p>RecyclerView的layoutManager，spanCount,orientation属性可以在xml中设置；</p>
</li>
<li><p>通过SpannableString设置TextView样式，减少TextView创建；</p>
</li>
<li><p>图片如果只是颜色不一致的话，可以使用tint着色器进行更改，不必进行图片切换，减少图片资源的引入；</p>
</li>
<li><p>ViewFlipper：翻转视图，可以用来实现轮播，大图滑动查看，Banner图，启动引导页等；</p>
</li>
<li><p>设置EditText文本：EditText.text &#x3D; Editable.Factory.getInstance().newEditable(“”)；</p>
</li>
<li><p>设置Button无样式显示：style&#x3D;”?android:attr&#x2F;borderlessButtonStyle”；</p>
</li>
<li><p>防止同时按下两个按钮触发两个事件,在style中配置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;style name=<span class="string">&quot;AppTheme&quot;</span> parent=<span class="string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 防止同时按下两个按钮 --&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android:windowEnableSplitTouch&quot;</span>&gt;<span class="literal">false</span>&lt;/item&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android:splitMotionEvents&quot;</span>&gt;<span class="literal">false</span>&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>金钱等两位小数的值使用BigDecimal类型；</p>
</li>
<li><p>对于简单方案，例如调用list集合的扩展函数，可以不使用{ }的lambda形式，直接使用（类名：属性）的方式，易于阅读；</p>
</li>
<li><p>a &#x3D; b.also { b &#x3D; a } ，交换两个属性，不用来回赋值了，每一次触发，都会进行调换；</p>
</li>
<li><p>by lazy只能作用于val关键字标注的属性，当属性用到的时候才会初始化”lazy{}”里面的内容，而且再次调用属性的时候，只会得到结果，而不会再次执行lazy{}的运行过程；</p>
</li>
<li><p>绘制RecyclerView后，可以设置tools:listitem&#x3D;”@layout&#x2F;list_item”，显示对应的Item布局；</p>
</li>
<li><p>解决android:animateLayoutChanges&#x3D;”true”动画跳跃问题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.JELLY_BEAN)&#123;		 	 		</span><br><span class="line">		父布局?.layoutTransition!!.enableTransitionType(LayoutTransition.CHANGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态的在代码里进行设置edittext限制规则：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">editText.setKeyListener(DigitsKeyListener.getInstance(<span class="string">&quot;1234567890&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>单独对某个值或者对象判空并操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">bean?.let &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取某个对象中的各个属性进行操作：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">with(bean) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>既判空也取各个属性，并且不需要依靠it来调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">bean.run &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>apply：1、适用于run函数的任何场景，一般用于初始化一个对象实例的时候，操作对象属性，并最终返回这个对象。<br>2、动态inflate出一个XML的View的时候需要给View绑定数据也会用到.<br>3、一般可用于多个扩展函数链式调用<br>4、数据model多层级包裹判空处理的问题</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">bean?.apply &#123;</span><br><span class="line">    <span class="comment">//第一层级不为空</span></span><br><span class="line">&#125;?.name?.apply &#123;</span><br><span class="line">    <span class="comment">//第二层级不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>also</code> 对于执行一些将上下文对象作为参数的操作很有用。 对于需要引用对象而不是其属性与函数的操作，或者不想屏蔽来自外部作用域的 <code>this</code> 引用时，请使用 <code>also</code>。可以将其理解为“并且用该对象执行以下操作”</p>
</li>
<li><p>要善于使用解构声明，把一个对象，或者一个方法直接返回所需的多个变量：</p>
<p>小括号里面的变量会从对象中依次调取，如果有用不到的参数，使用<code>_</code>替代</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> (name,age) = f1()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>: MyTestBean &#123;</span><br><span class="line">   <span class="keyword">return</span> MyTestBean(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合中也可以使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf(</span><br><span class="line">    MyTestBean(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>),</span><br><span class="line">    MyTestBean(<span class="string">&quot;456&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    MyTestBean(<span class="string">&quot;789&quot;</span>, <span class="number">2</span>),</span><br><span class="line">    MyTestBean(<span class="string">&quot;000&quot;</span>, <span class="number">3</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((name,age) <span class="keyword">in</span> list)&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;name: <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个变量是否为null，并做对应的处理，可以使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">haha?.let &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;不为null&quot;</span>)</span><br><span class="line">        &#125; ?: run &#123;</span><br><span class="line">  					<span class="comment">//注意：let函数中存在多个let判断的话，有一个为null，都会进入run</span></span><br><span class="line">            Log.e(<span class="string">&quot;JP&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当声明的变量名存在相同概念的情况，私有的变量名使用_标识</p>
</li>
<li><p>TextView.lineCount：获取显示的文案有几行；TextView.layout.getLineWidth(0)：指定第几行文案显示的宽度；TextView.layout.getLineStart(0)：指定第几行显示的第一个字占所有文字的脚标；TextView.layout.getLineEnd(0)：指定第几行显示的最后一个字占所有文字的脚标。</p>
<p>以上调用应该在TextView绘制完成，即post{dothing}</p>
</li>
<li><p>当进行类型转换的时候，如果可能存在null的情况，应使用as?</p>
</li>
<li><p>判断字符串是否为空：</p>
<p>isNullOrEmpty : 为空指针或者字串长度为0时返回true，非空串与可空串均可调用。<br>isNullOrBlank : 为空指针或者字串长度为0或者全为空格时返回true，非空串与可空串均可调用。<br>isEmpty : 字串长度为0时返回true，只有非空串可调用。<br>isBlank : 字串长度为0或者全为空格时返回true，只有非空串可调用。<br>isNotEmpty : 字串长度大于0时返回true，只有非空串可调用。<br>isNotBlank : 字串长度大于0且不是全空格串时返回true，只有非空串可调用。</p>
</li>
<li><p>如果要对集合做很多或复杂的操作时，可以考虑转换为Sequence序列，再执行，提升处理效率</p>
</li>
<li><p>以字符串形式展示集合的数据时，使用list.joinToString(separator &#x3D; “ | “, prefix &#x3D; “start: “, postfix &#x3D; “: end”) – separator ：每个元素间的分割符</p>
<p>–prefix ：数据开始的头描述</p>
<p>–postfix ：数据结束的尾描述</p>
</li>
<li><p>在设置颜色**<code>colors.xml</code><strong>时，命名规则可以为</strong><code>_颜色值</code>**</p>
</li>
<li><p>在项目中可以创建多个styles.xml文件，这个文件名称并没有作用，起作用的是在文件 里xml的<code>&lt;style&gt;</code>标签。将通用的样式写到style中，布局里面直接加载style，不要再一个一个编写属性。</p>
</li>
<li><p>对于详情页面数据的访问，处理某个实时状态的话，用轮询访问服务器。</p>
</li>
<li><p>布局中使用分割线的话，可以考虑LinearLayout中的divider。</p>
<p><code>divider</code>：传入分割线的<code>drawable</code>，可以是一个图片，也可以是自己通过<code>xml</code>实现的<code>drawable</code>。例如系统的分割线：@android:drawable&#x2F;divider_horizontal_bright</p>
<p><code>showDividers</code>：分割线显示的位置，<code>beginning/middle/end</code>，分割对应头部、中间、尾部。</p>
<p><code>dividerPadding</code>：分割线距离两边的间距。</p>
</li>
<li><p>如果不想使用外边距和View实现间距，考虑使用Space标签，它是一个空实现，因此它只占位置，而不去渲染，使用它来进行占位填充比其它控件更加高效</p>
</li>
<li><p>对比两个字符串，但是需要忽略大小写时，使用old.equals(new, ignoreCase &#x3D; <strong>true</strong>)</p>
</li>
<li><p>判断一个字符串是否为空字符串或者空格，最后加上为null的默认值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">str?.ifBlank &#123; <span class="string">&quot;123&quot;</span> &#125; ?: <span class="string">&quot;000&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串移除相关：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">data</span> = <span class="string">&quot;**hi dhl**&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除前缀</span></span><br><span class="line">println(<span class="keyword">data</span>.removePrefix(<span class="string">&quot;**&quot;</span>)) <span class="comment">// hi dhl**</span></span><br><span class="line"><span class="comment">// 移除后缀</span></span><br><span class="line">println(<span class="keyword">data</span>.removeSuffix(<span class="string">&quot;**&quot;</span>)) <span class="comment">// **hi dhl</span></span><br><span class="line"><span class="comment">// 移除前缀和后缀</span></span><br><span class="line">println(<span class="keyword">data</span>.removeSurrounding(<span class="string">&quot;**&quot;</span>)) <span class="comment">// hi dhl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一次出现分隔符后的字符串</span></span><br><span class="line">println(<span class="keyword">data</span>.substringAfter(<span class="string">&quot;**&quot;</span>)) <span class="comment">// hi dhl**</span></span><br><span class="line"><span class="comment">// 如果没有找到，返回原始字符串</span></span><br><span class="line">println(<span class="keyword">data</span>.substringAfter(<span class="string">&quot;--&quot;</span>)) <span class="comment">// **hi dhl**</span></span><br><span class="line"><span class="comment">// 如果没有找到，返回默认字符串 &quot;no match&quot;</span></span><br><span class="line">println(<span class="keyword">data</span>.substringAfter(<span class="string">&quot;--&quot;</span>,<span class="string">&quot;no match&quot;</span>)) <span class="comment">// no match</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> = <span class="string">&quot;&#123;JAVA | KOTLIN | C++ | PYTHON&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除前缀和后缀</span></span><br><span class="line">println(<span class="keyword">data</span>.removeSurrounding(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>)) <span class="comment">// JAVA | KOTLIN | C++ | PYTHON</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以考虑减少if-else的判断，使用require(){}和checkXXX(){}进行检测</p>
</li>
<li><p>TextView设置跑马灯效果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">                   ...</span><br><span class="line">                   android:ellipsize=<span class="string">&quot;marquee&quot;</span></span><br><span class="line">                   android:focusable=<span class="string">&quot;true&quot;</span></span><br><span class="line">                   android:focusableInTouchMode=<span class="string">&quot;true&quot;</span></span><br><span class="line">                   android:marqueeRepeatLimit=<span class="string">&quot;marquee_forever&quot;</span></span><br><span class="line">                   android:maxWidth=<span class="string">&quot;120dp&quot;</span></span><br><span class="line">                   android:maxLines=<span class="string">&quot;1&quot;</span></span><br><span class="line">                   android:scrollHorizontally=<span class="string">&quot;true&quot;</span></span><br><span class="line">                   android:singleLine=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">                   </span><br><span class="line">                   &lt;requestFocus /&gt;</span><br><span class="line">  </span><br><span class="line">               &lt;/TextView&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意的是，不要设置高度，可以考虑设置 android:paddingVertical。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>16进制颜色透明度</title>
    <url>/2021/03/06/color-transparency-16/</url>
    <content><![CDATA[<p>Android中的颜色值通常遵循RGB&#x2F;ARGB标准，使用时通常以“#”字符开头，以16进制表示。</p>
<p>ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。以颜色值 #FF99CC00 为例，其中，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。</p>
<span id="more"></span>

<h4 id="透明度换算"><a href="#透明度换算" class="headerlink" title="透明度换算"></a>透明度换算</h4><p>透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶（256的一半当然是128，但因为是从0开始，所以实际上是127）。</p>
<p>透明度 和 不透明度 是两个概念， 它们加起来是1，或者100%.</p>
<p>ARGB 中的透明度alpha，表示的是不透明度。</p>
<h5 id="换算过程"><a href="#换算过程" class="headerlink" title="换算过程"></a>换算过程</h5><p>将透明度转换成不透明度(转换方式参考“透明度”，第2条) 。不透明度为60%</p>
<p>不透明度乘以255。 我们得到结果：153</p>
<p>将计算结果转换成16进制。得到最终的不透明度：99</p>
<p>将不透明度和颜色值拼接成ARGB格式。得到最终的颜色值： #99FFFFFF</p>
<table>
<thead>
<tr>
<th>透明度</th>
<th>16进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>100%</td>
<td>00</td>
</tr>
<tr>
<td>95 %</td>
<td>0D</td>
</tr>
<tr>
<td>90 %</td>
<td>1A</td>
</tr>
<tr>
<td>85 %</td>
<td>26</td>
</tr>
<tr>
<td>80 %</td>
<td>33</td>
</tr>
<tr>
<td>75 %</td>
<td>40</td>
</tr>
<tr>
<td>70 %</td>
<td>4D</td>
</tr>
<tr>
<td>65 %</td>
<td>59</td>
</tr>
<tr>
<td>60 %</td>
<td>66</td>
</tr>
<tr>
<td>55 %</td>
<td>73</td>
</tr>
<tr>
<td>50 %</td>
<td>80</td>
</tr>
<tr>
<td>45 %</td>
<td>8C</td>
</tr>
<tr>
<td>40 %</td>
<td>99</td>
</tr>
<tr>
<td>35 %</td>
<td>A6</td>
</tr>
<tr>
<td>30 %</td>
<td>B3</td>
</tr>
<tr>
<td>25 %</td>
<td>BF</td>
</tr>
<tr>
<td>20 %</td>
<td>CC</td>
</tr>
<tr>
<td>15 %</td>
<td>D9</td>
</tr>
<tr>
<td>10 %</td>
<td>E6</td>
</tr>
<tr>
<td>5 %</td>
<td>F2</td>
</tr>
<tr>
<td>0 %</td>
<td>FF</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Color</tag>
      </tags>
  </entry>
  <entry>
    <title>低耦合高内聚</title>
    <url>/2021/06/25/coupling-cohesion/</url>
    <content><![CDATA[<p>软件编程总原则：低耦合，高内聚。</p>
<span id="more"></span>

<h5 id="耦合："><a href="#耦合：" class="headerlink" title="耦合："></a>耦合：</h5><p>软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。</p>
<p>耦合度由高到低排列如下：</p>
<ul>
<li>内容耦合：当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</li>
<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>
<li>外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</li>
<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。</li>
<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>
<li>数据耦合：模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</li>
<li>非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</li>
</ul>
<p>在设计中采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</p>
<h5 id="内聚："><a href="#内聚：" class="headerlink" title="内聚："></a>内聚：</h5><p>内聚是一个模块内部各成分之间相关联程度的度量，是信息隐蔽和局部化概念的自然扩展。</p>
<p>内聚按紧密程度从低到高排列次序为：</p>
<ul>
<li>偶然内聚：一个模块的各成分间毫无关系。</li>
<li>逻辑内聚：将逻辑上相关的功能被放在同一模块中，每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能 。</li>
<li>时间内聚：某些功能需要在同一时间组合执行，例如初始化。</li>
<li>过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。简单的说就是如果一个模块内的处理元素是相关的，而且必须以特定次序执行则称为过程内聚。</li>
<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。</li>
<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。</li>
<li>信息内聚：如果模块进行许多操作，每个都有各自的入口点，每个操作的代码相对独立，而且所有的操作都对相同的数据结构完成。</li>
<li>功能内聚：模块内所有元素的各个组成部分全部都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus和BroadCast的差异</title>
    <url>/2021/06/25/eventbus-broadcast/</url>
    <content><![CDATA[<p>消息传递的实现，可以使用EventBus、广播、观察者。任何一种方式都有它的利弊，存在差异。</p>
<span id="more"></span>

<ul>
<li><h5 id="广播BroadCastReceiver"><a href="#广播BroadCastReceiver" class="headerlink" title="广播BroadCastReceiver"></a>广播BroadCastReceiver</h5></li>
</ul>
<p>全局广播：它是重量级的，会消耗很多的资源，但是可以跨进程通信，这个特点是其他方案做不到的。</p>
<p>本地广播：也会消耗很多资源，较全局广播轻量些，它可以拿到Context、Intent等和Android系统紧密相关的上下文，这样就方便数据的传递和接收。但是，获取到的这些对象，并不是像Activity那样获取到后做最全的事情。</p>
<p>作为四大组件之一，广播同SDK的交互比较好。所以系统级的事件都是通过广播来实现的。</p>
<p>谨记：广播是消耗时间、空间最多的一种方式。</p>
<ul>
<li><h5 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h5></li>
</ul>
<p>开发中使用最多的一种方式，调度灵活，不依赖Context，父类对于通知的监听和处理可以继承给子类，设置通知的优先级，粘滞事件能够保证通知不会因 Subscriber 的不在场而忽略。</p>
<p>使用起来也简单，通过注册来监听数据变化即可。</p>
<p>使用完成后需要解绑监听，并且无法跨进程传递消息。</p>
<ul>
<li><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5></li>
</ul>
<p>观察者的实现比较简单，性能上所以是最好的，但是无法控制优先级、粘滞事件，耦合性比EventBus大。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的学习</title>
    <url>/2022/05/16/http/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>HTTP：HyperText Transfer Protocol，超文本传输协议。它是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网数据通信的基础。</p>
<span id="more"></span>

<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>HTTP是一个客户端终端和服务器端请求和应答的标准（TCP），通过使用网页浏览器、网络爬虫或者其他工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。称此客户端为用户代理程序。应答的服务器上存储着一些资源，称其为源服务器。客户端和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或隧道。</p>
<p>尽管TCP&#x2F;IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP&#x2F;IP协议族使用TCP作为其传输层。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>步骤如下：</p>
<ul>
<li>客户端连接到服务器：即两端之间建立一个TCP套接字连接；</li>
<li>发送HTTP请求：通过TCP套接字，客户端向服务端发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成；</li>
<li>服务器接受请求并返回HTTP响应：服务器解析请求，定位请求资源，服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成；</li>
<li>释放TCP连接：若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求；</li>
<li>客户端解析内容：客户端先解析状态行，查看表明请求是否成功的状态码。然后解析每一个响应头，响应头告知以下为若干字节的文档的字符集。客户端读取响应数据，并格式化后显示。</li>
</ul>
<p>请求必定由客户端发出，而服务器端回复响应。</p>
<h4 id="无状态保存"><a href="#无状态保存" class="headerlink" title="无状态保存"></a>无状态保存</h4><p>HTTP是一种不保存状，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快的处理大量事务，确保协议的可伸缩性，而特意设计成如此简单的。</p>
<p>HTTP&#x2F;1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。</p>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次响应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><ul>
<li>GET：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中；</li>
<li>HEAD：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）；</li>
<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有；</li>
<li>PUT：向指定资源位置上传其最新内容；</li>
<li>DELETE：请求服务器删除Request-URI所标识的资源；</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断；</li>
<li>OPTIONS：使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作；</li>
<li>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>方法名称是区分大小的；</li>
<li>服务器至少应该实现GET和HEAD方法；</li>
<li>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连；</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制；</li>
</ul>
<h4 id="HTTP状态码简述"><a href="#HTTP状态码简述" class="headerlink" title="HTTP状态码简述"></a>HTTP状态码简述</h4><ul>
<li>1xx——信息性状态码——接收的请求正在处理</li>
<li>2xx——成功状态码——请求正常处理完毕</li>
<li>3xx——重定向状态码——需要进行附加操作以完成请求</li>
<li>4xx——客户端错误状态码——服务器无法处理请求</li>
<li>5xx——服务器错误状态码——服务器处理请求出错</li>
</ul>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>
<ul>
<li>User-Agent：产生请求的浏览器类型；</li>
<li>Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ <em>&#x2F;</em> ” 指示可接受全部类型，用“ type&#x2F;* ”指示可接受 type 类型的所有子类型；</li>
<li>Accept-Language：客户端可接受的自然语言；</li>
<li>Accept-Encoding：客户端可接受的编码压缩格式；</li>
<li>Accept-Charset：可接受的应答的字符集；</li>
<li>Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机；</li>
<li>connection：连接方式(close 或 keepalive)；</li>
<li>Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie。</li>
</ul>
<h4 id="uri、url、urn三者区别"><a href="#uri、url、urn三者区别" class="headerlink" title="uri、url、urn三者区别"></a>uri、url、urn三者区别</h4><ul>
<li><p>uri：只用来唯一标识资源，不进行查找、定位。</p>
</li>
<li><p>url：唯一标识资源，并且规定了如何查找、定位资源。</p>
</li>
<li><p>urn：规定了资源的命名规则。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS的学习</title>
    <url>/2022/05/16/https/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Hypertext Transfer Protocol Secure（超文本传输安全协议）：是一种网络安全传输协议。在http协议的基础上开发的，实现了加密传输，解决了http协议传输不安全的问题。</p>
<p>HTTPS &#x3D; HTTP+SSL&#x2F;TLS</p>
<span id="more"></span>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>客户端请求HTTPS网址，然后连接到server的443端口；</li>
<li>采用HTTPS协议的服务器必须要有一套数字CA（Certification Authority）证书，证书是需要申请的，并由专门的数字证书认证机构（CA）通过非常严格的审核之后颁发的电子证书（当然了是要钱的，安全级别越高价格越贵）。颁发证书的同时会产生一个私钥和公钥。私钥由服务器自己保存，不可泄漏。公钥则是附带在证书的信息中，可以开放的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改；</li>
<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥的大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等；</li>
<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码KEY，并使用公钥A将其加密；</li>
<li>客户端把机密后的随机码KEY发送给服务器，作为后面对称加密算法的密钥；</li>
<li>服务器在收到随机码KEY之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称机密愉快地进行通信了；</li>
<li>服务器使用密钥（随机码KEY）对数据进行对称加密并发送给客户端，客户端使用相同的密钥（随机码KEY）解密数据；</li>
<li>双方使用对称加密愉快地传输所有数据。</li>
</ul>
<h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><p>HTTPS解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也就是对称加密和非对称加密的混合使用。</p>
<p>在内容传输的加密上使用的是对称加密，证书验证阶段使用非对称加密。</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>加密和解密使用的都是同一个密钥，常见的对称加密有DES,3DES和AES等。</p>
<ul>
<li>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密加密比较大的数据；</li>
<li>缺点：1.交易双方需要使用相同的密钥，也就无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，因此对称加密算法的安全性等不到保证；2.每对用户每次使用对称加密算法是，都需要使用其他人不知道的唯一密钥，这会使得发收信双方所拥有得要是数量急剧增长，密钥管理成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</li>
</ul>
<p>被加密的数据在传输过程中是无规则的乱码，即便被第三方截获，在没有密钥的情况下也无法解密数据，也就保证了数据的安全。但是有一个致命的问题，那就是既然双方要使用同样的密钥，那就必然要在传输数据之前先由一方把密钥传给另一方，那么在此过程中密钥就很有可能被截获，这样一来加密的数据也会被轻松解密。</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥和私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有对应的公钥才能解密。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥对外公开；得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；甲方在用自己保存的私钥对加密后的信息进行解密。</p>
<ul>
<li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li>
<li>确定：计算量比较大，加密和解密速度相对比对称算法慢很多。</li>
</ul>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>Secure Socket Layer：安全套接字层。用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上传输过程中不会被截取。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。</p>
<p>SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>Transport Layer Security：传输层安全协议。用于两个应用程序之间提供保密性和数据完整性。</p>
<p>该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<h5 id="主要增强内容"><a href="#主要增强内容" class="headerlink" title="主要增强内容"></a><strong>主要增强内容</strong></h5><p>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：</p>
<ol>
<li>更安全的MAC算法</li>
<li>更严密的警报</li>
<li>“灰色区域”规范的更明确的定义</li>
</ol>
<h4 id="SSL-x2F-TLS协议提供的服务主要有："><a href="#SSL-x2F-TLS协议提供的服务主要有：" class="headerlink" title="SSL&#x2F;TLS协议提供的服务主要有："></a>SSL&#x2F;TLS协议提供的服务主要有：</h4><ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ol>
<h4 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h4><ul>
<li>最最最最重要的区别就是安全性，HTTP明文传输，不对数据进行加密安全性较差。HTTPS（HTTP+SSL&#x2F;TLS）的数据传输过程是加密的，安全性较好。</li>
<li>使用HTTPS协议需要申请CA证书，一般免费证书较少，因而需要一定的费用。证书颁发机构如：Symantec、Comodo、DigiCert和GlobalSign等。</li>
<li>HTTP页面响应速度比HTTPS快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。</li>
<li>由于HTTPS是建构在SSL&#x2F;TLS之上的HTTP协议，所以，要比HTTP更耗费服务器资源。</li>
<li>HTTPS和HTTP使用的是完全不同连接方式，用的端口也不一样，前者是443，后者是80。</li>
</ul>
<h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ul>
<li>在相同的网络环境中，HTTPS相比HTTP无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPSd的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS需要更多的服务器资源，也会导致成本升高。</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-开发环境配置</title>
    <url>/2021/02/25/java-environment-configuration/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul>
<li><p>进入<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html%E5%AE%98%E7%BD%91%EF%BC%8C%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E9%80%89%E6%8B%A9Accept">http://www.oracle.com/technetwork/java/javase/downloads/index.html官网，找到需要下载的版本，选择Accept</a> License Agreement，点击下载。</p>
</li>
<li><p>新建一个文件夹java，里面创建jdk和jre两个文件夹。</p>
</li>
<li><p>双击下载的exe文件，开始安装。</p>
</li>
<li><p>安装路径选择java&#x2F;jdk，当提示安装jre时，安装路径选择java&#x2F;jre。区分jdk和jre分别安装。</p>
</li>
<li><p>安装完成之后，返回桌面，选中此电脑或者计算机，依次进入右键–属性–高级系统设置–高级–环境变量。</p>
</li>
<li><p>在系统变量中新建JAVA_HOME，取值为jdk安装目录</p>
</li>
<li><p>在系统变量中新建CLASSPATH，取值为：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure>

<p>特别注意！！最前面有个点，千万不要忘记！！ </p>
<ul>
<li>在Path中添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置完成之后，依次点击确定退出。</p>
</li>
<li><p>使用快捷键Win+R，打开运行，输入cmd，打开命令提示符窗口，执行命令：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure>

<ul>
<li>如果出现类似以下的信息：</li>
</ul>
<p>java version “1.8.0_162” Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</p>
<p>则说明Java环境配置成功。 </p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>目前使用的Linux为Centos7。 </p>
<ul>
<li>查看系统自带的openJDK版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -qa | grep jdk</span><br></pre></td></tr></table></figure>

<ul>
<li>依次删除这些jdk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y remove jdk名称</span><br></pre></td></tr></table></figure>

<ul>
<li><p>安装之前，我们可以根据需求，在根目录中创建专门安装软件的目录（e.g. software）。</p>
</li>
<li><p>此时，如果使用普通账户的话，会有权限不足的提示，就需要我们给用户添加root权限。</p>
</li>
</ul>
<p>给普通账户添加权限：</p>
<blockquote>
<ul>
<li><p>使用su，进入root账户下。</p>
</li>
<li><p>查看&#x2F;etc&#x2F;sudoers目录权限状态，是否可编辑。</p>
</li>
<li><p>设置sudoers目录为可写状态：440，执行命令chmod 777 sudoers，将sudoers目录变成可读可写可执行。</p>
</li>
<li><p>执行命令vim &#x2F;etc&#x2F;sudoers,点击i键，找到</p>
<p>Allow root to run any commands anywhere</p>
<p>root ALL&#x3D;(ALL) ALL</p>
<p>在下面添加：用户名 ALL&#x3D;(ALL) ALL</p>
<p>点击esc，输入：wq保存。</p>
</li>
<li><p>此时完成账户的权限配置，接下来要把sudoers目录的权限复原，执行命令chmod 440 sudoers。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>以下可以使用登录的普通账户进行操作，注意的是命令前面需要加上sudo（即root权限操作）</p>
</li>
<li><p>创建软件安装目录（e.g. software）</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> software</span><br></pre></td></tr></table></figure>

<ul>
<li>进入目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> software</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个新的java目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> java</span><br></pre></td></tr></table></figure>

<ul>
<li>进入java，我们要在这个目录里进行安装配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> java</span><br></pre></td></tr></table></figure>

<ul>
<li>下载jdk的tar包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://download.oracle.com/otn-pub/java/jdk/......</span><br></pre></td></tr></table></figure>

<p>下载地址在<a href="http://www.oracle.com/technetwork/java/javase/overview/index.html%E7%9A%84Downloads%E4%B8%AD%E5%AF%BB%E6%89%BE%EF%BC%8C%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E7%82%B9%E5%87%BBJDK">http://www.oracle.com/technetwork/java/javase/overview/index.html的Downloads中寻找，找到想要下载的版本，点击JDK</a> Download，选择Accept License Agreement ，右键.tar.gz格式，复制链接地址。</p>
<p>部分版本下载地址：</p>
<p>32位：</p>
<p>1.8-171：<a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-i586.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-i586.tar.gz</a></p>
<p>1.8-172：<a href="http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-i586.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-i586.tar.gz</a></p>
<p>64位：</p>
<p>1.8-171：<a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz</a></p>
<p>1.8-172：<a href="http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-x64.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-x64.tar.gz</a></p>
<p>10.0.1：<a href="http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz">http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz</a></p>
<ul>
<li>下载完成后，进行解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf jdk名称.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>删除压缩包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> jdk名称.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑&#x2F;etc&#x2F;profile文件，配置环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/目录名/java（自定义目录名）/jdk目录名称</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Esc</p>
</li>
<li><p>:wq保存并退出</p>
</li>
<li><p>重新加载profile目录</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure>

<ul>
<li>成功则会显示类似于以下信息</li>
</ul>
<p>java version “1.8.0_144”</p>
<p>Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</p>
<p>Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-环境配置</title>
    <url>/2021/03/24/java-install-jdk/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul>
<li><p>进入<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> 官网，找到需要下载的版本，选择Accept License Agreement，点击下载。</p>
</li>
<li><p>新建一个文件夹java，里面创建jdk和jre两个文件夹。</p>
</li>
<li><p>双击下载的exe文件，开始安装。 </p>
</li>
<li><p>安装路径选择java&#x2F;jdk，当提示安装jre时，安装路径选择java&#x2F;jre。区分jdk和jre分别安装。</p>
</li>
<li><p>安装完成之后，返回桌面，选中此电脑或者计算机，依次进入右键–属性–高级系统设置–高级–环境变量。 </p>
</li>
<li><p>在系统变量中新建JAVA_HOME，取值为jdk安装目录 –在系统变量中新建CLASSPATH，取值为： <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code> 特别注意！！最前面有个点，千万不要忘记！！ </p>
</li>
<li><p>在Path中添加 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></p>
</li>
<li><p>设置完成之后，依次点击确定退出。 </p>
</li>
<li><p>使用快捷键Win+R，打开运行，输入cmd，打开命令提示符窗口，执行命令：<code>java -version</code></p>
</li>
<li><p>如果出现类似以下的信息：</p>
</li>
</ul>
<p> <code>java version &quot;1.8.0_162&quot; Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</code></p>
<p> 则说明Java环境配置成功。 </p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>目前使用的Linux为Centos7。 </p>
<ul>
<li>查看系统自带的openJDK版本</li>
</ul>
<p><code>rpm -qa | grep jdk</code></p>
<ul>
<li>依次删除这些jdk</li>
</ul>
<p><code>yum -y remove jdk名称</code></p>
<ul>
<li><p>安装之前，我们可以根据需求，在根目录中创建专门安装软件的目录（e.g. software）。</p>
</li>
<li><p>此时，如果使用普通账户的话，会有权限不足的提示，就需要我们给用户添加root权限。</p>
</li>
</ul>
<p>给普通账户添加权限：</p>
<ol>
<li>使用su，进入root账户下。</li>
<li>ll查看&#x2F;etc&#x2F;sudoers目录权限状态，是否可编辑。</li>
<li>设置sudoers目录为可写状态：440，执行命令<code>chmod 777 sudoers</code>，将sudoers目录变成可读可写可执行。</li>
<li>执行命令<code>vim /etc/sudoers</code>,点击i键，找到</li>
</ol>
<p>## Allow root to run any commands anywhere</p>
<p>root ALL&#x3D;(ALL) ALL</p>
<p>在下面添加：用户名 ALL&#x3D;(ALL) ALL</p>
<p>点击esc，输入：wq保存。</p>
<ol>
<li>此时完成账户的权限配置，接下来要把sudoers目录的权限复原，执行命令chmod 440 sudoers。</li>
</ol>
<ul>
<li><p>以下可以使用登录的普通账户进行操作，注意的是命令前面需要加上sudo（即root权限操作）</p>
</li>
<li><p>创建软件安装目录（e.g. software）</p>
</li>
</ul>
<p><code>sudo mkdir software</code></p>
<ul>
<li>进入目录</li>
</ul>
<p><code>cd software</code></p>
<ul>
<li>创建一个新的java目录</li>
</ul>
<p><code>mkdir java</code></p>
<ul>
<li>进入java，我们要在这个目录里进行安装配置</li>
</ul>
<p><code>cd java</code></p>
<ul>
<li>下载jdk的tar包</li>
</ul>
<p><code>wget http://download.oracle.com/otn-pub/java/jdk/......</code></p>
<p>下载地址在<a href="http://www.oracle.com/technetwork/java/javase/overview/index.html%E7%9A%84Downloads%E4%B8%AD%E5%AF%BB%E6%89%BE%EF%BC%8C%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E7%82%B9%E5%87%BBJDK">http://www.oracle.com/technetwork/java/javase/overview/index.html的Downloads中寻找，找到想要下载的版本，点击JDK</a> Download，选择Accept License Agreement ，右键.tar.gz格式，复制链接地址。</p>
<p>部分版本下载地址：</p>
<p>32位：</p>
<p>1.8-171：<a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-i586.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-i586.tar.gz</a></p>
<p>1.8-172：<a href="http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-i586.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-i586.tar.gz</a></p>
<p>64位：</p>
<p>1.8-171：<a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz</a></p>
<p>1.8-172：<a href="http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-x64.tar.gz">http://download.oracle.com/otn-pub/java/jdk/8u172-b11/a58eab1ec242421181065cdc37240b08/jdk-8u172-linux-x64.tar.gz</a></p>
<p>10.0.1：<a href="http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz">http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz</a></p>
<ul>
<li>下载完成后，进行解压</li>
</ul>
<p><code>tar -zxvf jdk名称.tar.gz</code></p>
<ul>
<li>删除压缩包</li>
</ul>
<p><code>rm jdk名称.tar.gz</code></p>
<ul>
<li>编辑&#x2F;etc&#x2F;profile文件，配置环境变量</li>
</ul>
<p><code>vim /etc/profile</code></p>
<p>在末尾添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/目录名/java（自定义目录名）/jdk目录名称</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:JAVA_HOME/jre/lib/rt.jar:JAVA_HOME/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=PATH:JAVA_HOME/bin&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Esc–:wq保存并退出</p>
</li>
<li><p>重新加载profile目录</p>
</li>
</ul>
<p><code>source /etc/profile</code></p>
<ul>
<li>检查是否安装成功</li>
</ul>
<p><code>java -version</code></p>
<ul>
<li>成功则会显示类似于以下信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java version <span class="string">&quot;1.8.0_144&quot;</span></span><br><span class="line"></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-四种对象引用的理解</title>
    <url>/2021/02/25/java-quote-object/</url>
    <content><![CDATA[<p>JDK1.2版本开始，为了在JVM中更加灵活的进行对象的垃圾回收，使程序灵活的控制对象的生命周期，加入把对象引用分为了四种级别：强引用、软引用、弱引用和虚引用。<br>级别对比：强引用 &gt; 软引用 &gt; 弱引用  &gt; 虚引用</p>
<span id="more"></span>

<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>这是使用最普遍的一种引用。一个对象具有强引用，那么垃圾回收器绝对不会回收它。当内存空间不足时，JVM宁愿抛出OOM错误，让程序终止，也不会随意回收强引用对象来解决内存不足。</p>
<p>&#x2F;&#x2F;强引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>如果想把强引用和某个对象之间的关联切断，可以显式的将引用赋值为null，JVM就会在合适的时候回收该对象。</p>
<h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>一个对象只具有软引用，当内存空间足够，垃圾回收器就不会回收它，如果内存不足，就会回收这些对象的内存，只要该对象没有被回收，就可以被程序使用。<br>软引用适合创建内存敏感的高速缓存，系统内存如果不足的时候，缓存是可以被释放的。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，JVM就会把这个软引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;String&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="comment">//如果软引用对象被GC回收，该方法返回的就是null</span></span><br><span class="line">sr.get();</span><br></pre></td></tr></table></figure>

<h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用就是将对象留在内存的能力弱于强引用，只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="comment">//gc进行垃圾回收</span></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>

<h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><p>虚引用不会决定对象的生命周期，当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。虚引用职能在其指向的对象从内存中移除掉之后才会加入到引用队列。其 get 方法一直返回 null 就是为了阻止其指向的几乎被销毁的对象重新复活。<br>虚引用主要用来跟踪被垃圾回收器回收的活动。它必须和引用队列 （ReferenceQueue）联合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;String&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>), queue);</span><br><span class="line">pr.get();</span><br></pre></td></tr></table></figure>

<p>不同点</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>何时被GC回收</th>
<th>何时终止</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>JVM停止运行时</td>
<td>对象一般状态</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足</td>
<td>内存不足时</td>
<td>对象缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>对象未被引用</td>
<td>gc运行后</td>
<td>对象缓存</td>
</tr>
<tr>
<td>虚引用</td>
<td>被回收时</td>
<td>内存使用控制，引用队列中对象被回收</td>
<td>用来跟踪对象被垃圾回收的活动</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>对于Kotlin协程的学习和使用</title>
    <url>/2021/05/18/kotlin-coroutine/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于协程的概念，官方文档说协程就是轻量级的线程，但是也不能就这么断定，在Android中使用时，因为Android是基于JVM的，JVM可以识别线程，却识别不了真正的协程。Android中的协程最终还是用线程，所以不能说是轻量级的线程。非Android中使用的协程，有些的确是轻量级的。</p>
<p>注意的是，单线程中的协程总的执行时间并不会比不用协程少。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>轻量：可以在单个线程上运行多个协程，因为<code>挂起</code>，不会使正在运行的协程的线程阻塞。<code>挂起</code>比阻塞节省内存，且支持多个并行操作。</p>
</li>
<li><p>内存泄漏更少：使用了结构化并发机制在一个作用域内执行多项操作。</p>
</li>
<li><p>内置取消支持：取消会自动在运行中的整个协程层次结构中传播。</p>
</li>
<li><p>Jetpack集成：许多 Jetpack 库都包含提供全面协程支持的扩展。某些库还提供自己的协程作用域。</p>
</li>
<li><p>线程自动切换：通过<code>withContext</code>函数和<code>Dispatch</code>简单快捷的自动切换线程。</p>
</li>
</ul>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>以在Android项目为例：通过gradle引入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//依赖协程核心库</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:版本号&quot;</span></span><br><span class="line">    <span class="comment">//依赖当前平台所对应的平台库</span></span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:版本号&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><ul>
<li><pre><code class="kotlin">//通常适用于单元测试场景，业务开发中不会使用，因为它是线程阻塞的
runBlocking &#123;
    //doSomeThing
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- ```kotlin</span><br><span class="line">  //此方式不会阻塞线程，但是它的生命周期会和app一致，且不能取消</span><br><span class="line">  //如果我们忘记保持对新启动的协程的引用，它会继续运行</span><br><span class="line">  //假如启动太多的协程并导致内存不足，就必须手动保持对所有已启动协程的引用并join，这样很容易出错</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">      //doSomeThing</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><pre><code class="kotlin">//推荐使用
class MainActivity : AppCompatActivity(), CoroutineScope &#123;

    private val job = Job()

    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job

    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val coroutineScope = CoroutineScope(coroutineContext)
        coroutineScope.launch(Dispatchers.Main) &#123;
            //doSomeThing
        &#125;

    &#125;

    override fun onDestroy() &#123;
        super.onDestroy()
          //停止协程
        job.cancel()
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### launch和async</span><br><span class="line"></span><br><span class="line">**launch**：用来启动一个协程并立即返回，像线程一样异步执行。协程中的未捕获异常会导致进程的crash。`launch`返回一个Job对象，通过`Job.join`方法可以同步等待协程的完成。</span><br><span class="line"></span><br><span class="line">**async**：用来启动一个协程并返回一个`Deferred`，使用`Deffered.await`可以获取`async`返回的结果，所以`async`相当于可以返回结果的`launch`。`async`内的代码中未捕获异常不会造成进程crash，而是会被储存到`Deferred`中返回。`Deferred`实际也是一个Job。`async`默认启动协程后立即执行，但是也可以通过参数指定启动方式为`CoroutineStart.LAZY`，此时只有调用了`await`时，才会启动协程。</span><br><span class="line"></span><br><span class="line">##### 参数说明</span><br><span class="line"></span><br><span class="line">源码：（launch和async差不多）</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">public fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job &#123;</span><br><span class="line">    val newContext = newCoroutineContext(context)</span><br><span class="line">    val coroutine = if (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) else</span><br><span class="line">        StandaloneCoroutine(newContext, active = true)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    return coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>context: CoroutineContext &#x3D; EmptyCoroutineContext</p>
<p>当前协程的上下文，用于在协程间参数传递。可以来声明当前协程在哪一个线程中声明，以及当前协程被中断后，在哪一个线程中恢复它。</p>
<p>最常用的功能是并发，典型场景就是多线程，即需要切换线程，我们经常这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mCoroutineScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">  	<span class="comment">//切换到IO线程执行事务</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mCoroutineScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">  	<span class="comment">//切换到主线程执行事务</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mCoroutineScope.launch(Dispatchers.Default) &#123;</span><br><span class="line">  	<span class="comment">//同IO线程，切换到IO线程执行事务</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mCoroutineScope.launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">  	<span class="comment">//不绑定在任何特定执行线程上</span></span><br><span class="line">  	<span class="comment">//在CPU进行密集型计算时使用</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>start: CoroutineStart &#x3D; CoroutineStart.DEFAULT</p>
<p>协程的启动参数，表示需要哪种方式启动。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CoroutineStart.DEFAULT：默认的启动方式，表示当前线程什么时候有空，就什么时候启动。</span><br><span class="line">CoroutineStart.LAZY：仅在需要时才延迟启动协程。</span><br><span class="line">CoroutineStart.ATOMIC：以原子方式（即以不可取消的方式）根据协程安排协程执行。</span><br><span class="line">CoroutineStart.UNDISPATCHED：未定义，通常用于自定义的启动方式，如果未自定义，则与 DEFAULT 启动方式一致。</span><br></pre></td></tr></table></figure>
</li>
<li><p>block: suspend CoroutineScope.() -&gt; Unit</p>
<p>协程真正要去执行的内容。</p>
</li>
</ul>
<p>Taps:</p>
<ul>
<li>withTimeoutOrNull()：使一个任务最多执行多少秒，超过时间自动取消</li>
<li>在activity和fragment里面，考虑使用<code>lifecycleScope</code>创建协程，绑定生命周期，这种方式创建的协程可以使用：<code>launchWhenStarted</code>、<code>launchWhenResumed</code>、<code>launchWhenCreated     </code>这些方法，里面执行的事务，会根据对应的生命周期开始和暂停</li>
<li>串行获取数据时，考虑使用<code>async</code>，通过<code>await</code>获取值</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-关于List集合的操作扩展函数</title>
    <url>/2021/02/25/kotlin-list-operate/</url>
    <content><![CDATA[<span id="more"></span>

<p>A</p>
<ul>
<li>associateBy({key},{value})：通过指定的条件，把list转换成map</li>
<li>any() : 判断是不是一个集合，若是，则在判断集合是否为空，若为空则返回false,反之返回true,若不是集合，则返回hasNext</li>
<li>any{…} : 判断集合中是否存在满足条件的元素。若存在则返回true,反之返回false</li>
<li>all{…} : 判断集合中的所有元素是否都满足条件。若是则返回true,反之则返回false</li>
<li>average() : 获取平均数</li>
</ul>
<h6 id="B"><a href="#B" class="headerlink" title="B"></a>B</h6><h6 id="C"><a href="#C" class="headerlink" title="C"></a>C</h6><ul>
<li>contains(元素) : 检查集合中是否包含指定的元素，若存在则返回true，反之返回false</li>
<li>componentX() ： 这个函数在前面的章节中提过多次了。用于获取元素。其中的X只能代表1..5。</li>
<li>count{}:返回符合匹配条件的元素的个数</li>
</ul>
<h6 id="D"><a href="#D" class="headerlink" title="D"></a>D</h6><ul>
<li>drop(num) : 过滤集合中前num个元素</li>
<li>dropWhile{…} : 相同条件下，和执行takeWhile{…}函数后得到的结果相反</li>
<li>dropLast(num) : 过滤集合中后num个元素</li>
<li>dropLastWhile{…} : 相同条件下，和执行takeLastWhile{…}函数后得到的结果相反</li>
<li>distinct() : 去除重复元素</li>
<li>distinctBy{…} : 根据操作元素后的结果去除重复元素</li>
</ul>
<h6 id="E"><a href="#E" class="headerlink" title="E"></a>E</h6><ul>
<li>elementAt(index) : 获取对应下标的元素。若下标越界，会抛出IndexOutOfBoundsException（下标越界）异常，同get(index)一样</li>
<li>elementAtOrElse(index,{…}) : 获取对应下标的元素。若下标越界，返回默认值，此默认值就是你传入的下标的运算值</li>
<li>elementAtOrNull(index) : 获取对应下标的元素。若下标越界，返回null</li>
</ul>
<h6 id="F"><a href="#F" class="headerlink" title="F"></a>F</h6><ul>
<li>first() : 获取第一个元素，若集合为空集合，这会抛出NoSuchElementException异常</li>
<li>first{} : 获取指定元素的第一个元素。若不满足条件，则抛出NoSuchElementException异常</li>
<li>firstOrNull() : 获取第一个元素，若集合为空集合，返回null</li>
<li>firstOrNull{} : 获取指定元素的第一个元素。若不满足条件，返回null</li>
<li>forEach{…} : 遍历元素。一般用作元素的打印</li>
<li>forEachIndexed{index,value} : 遍历元素，可获得集合中元素的下标。一般用作元素以及下标的打印</li>
<li>filter{…} : 把不满足条件的元素过滤掉</li>
<li>filterIndexed{…} : 和filter{}函数作用类似，只是可以操作集合中元素的下标（index）</li>
<li>filterNot{…} : 和filter{}函数的作用相反</li>
<li>filterNotNull() : 过滤掉集合中为null的元素。</li>
<li>fold{…} : 和reduce{}类似，但是fold{}有一个初始值</li>
<li>foldIndexed{…} : 和reduceIndexed{}类似，但是foldIndexed{}有一个初始值</li>
<li>foldRight{…} : 和reduceRight{}类似，但是foldRight{}有一个初始值</li>
<li>foldRightIndexed{…} : 和reduceRightIndexed{}类似，但是foldRightIndexed{}有一个初始值</li>
<li>flatMap() : 合并两个集合，可以在合并的时候对迭代元素值it做想要的操作</li>
<li>flatten() : 遍历一个单独的集合，包含给定嵌套集合里面的所有元素。</li>
</ul>
<h6 id="G"><a href="#G" class="headerlink" title="G"></a>G</h6><ul>
<li>getOrElse(index,{…}) : 获取对应下标的元素。若下标越界，返回默认值，此默认值就是你传入的下标的运算值</li>
<li>getOrNull(index) : 获取对应下标的元素。若下标越界，返回默认值，此默认值就是你传入的下标的运算值</li>
<li>groupBy() : 将集合中的元素按照某个条件分组，返回Map</li>
<li>get() : 获取索引所在的元素，没有则返回ArrayIndexOutOfBoundsException</li>
<li>getOrElse() : 获取索引所在的元素，没有就返回默认值</li>
<li>getOrNull() : 获取索引所在的元素，没有就返回nul</li>
</ul>
<h6 id="H"><a href="#H" class="headerlink" title="H"></a>H</h6><h6 id="I"><a href="#I" class="headerlink" title="I"></a>I</h6><ul>
<li>indexOf(元素) : 返回指定元素的下标，若不存在，则返回-1</li>
<li>indexOfFirst{…} : 返回第一个满足条件元素的下标，若不存在，则返回-1</li>
<li>indexOfLast{…} : 返回最后一个满足条件元素的下标，若不存在，则返回-1</li>
</ul>
<h6 id="J"><a href="#J" class="headerlink" title="J"></a>J</h6><h6 id="K"><a href="#K" class="headerlink" title="K"></a>K</h6><h6 id="L"><a href="#L" class="headerlink" title="L"></a>L</h6><ul>
<li>last() : 获取最后一个元素，若集合为空集合，这会抛出NoSuchElementException异常</li>
<li>last{} : 获取指定元素的最后一个元素。若不满足条件，则抛出NoSuchElementException异常</li>
<li>lastOrNull{} : 获取指定元素的最后一个元素。若不满足条件，返回null</li>
<li>lastOrNull() : 获取最后一个元素，若集合为空集合，返回null</li>
</ul>
<h6 id="M"><a href="#M" class="headerlink" title="M"></a>M</h6><ul>
<li>map():重组所用到的函数</li>
<li>max() : 获取集合中最大的元素，若为空元素集合，则返回null</li>
<li>maxBy{…} : 获取方法处理后返回结果最大值对应那个元素的初始值，如果没有则返回null</li>
<li>min() : 获取集合中最小的元素，若为空元素集合，则返回null</li>
<li>minBy{…} : 获取方法处理后返回结果最小值对应那个元素的初始值，如果没有则返回null</li>
<li>mapIndexed() : 除了得到转换后的结果，还可以拿到index(索引)</li>
<li>mapNotNull() : 执行方法转换前过滤掉为null的元素</li>
</ul>
<h6 id="N"><a href="#N" class="headerlink" title="N"></a>N</h6><ul>
<li>none() : 如果集合中没有元素，则返回true，否则返回false</li>
<li>none{…} : 如果集合中没有符合匹配条件的元素，返回true，否则返回false</li>
</ul>
<h6 id="O"><a href="#O" class="headerlink" title="O"></a>O</h6><h6 id="P"><a href="#P" class="headerlink" title="P"></a>P</h6><ul>
<li>partition():将原始集合拆分两个集合，一个集合包含判断条件为true的元素，另一个集合包含判断条件为false的元素</li>
<li>plus() : 合并两个List</li>
</ul>
<h6 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h6><h6 id="R"><a href="#R" class="headerlink" title="R"></a>R</h6><ul>
<li>reversed() : 反序。即和初始化的顺序反过来。</li>
<li>reduce{…} : 从集合中的第一项到最后一项的累计操作。</li>
<li>reduceIndexed{…} : 和reduce{}作用相同，只是其可以操作元素的下标(index)</li>
<li>reduceRight{…} : 从集合中的最后一项到第一项的累计操作。</li>
<li>reduceRightIndexed{…} : 和reduceRight{}作用相同，只是其可以操作元素的下标(index)</li>
<li>retainAll(list)：取两个集合的交集</li>
</ul>
<h6 id="S"><a href="#S" class="headerlink" title="S"></a>S</h6><ul>
<li>single() : 若集合的长度等于0,则抛出NoSuchElementException异常，若等于1，则返回第一个元素。反之，则抛出IllegalArgumentException异常</li>
<li>single{} : 找到集合中满足条件的元素，若元素满足条件，则返回该元素。否则会根据不同的条件，抛出异常。这个方法慎用</li>
<li>singleOrNull() : 若集合的长度等于1,则返回第一个元素。否则，返回null</li>
<li>singleOrNull{} : 找到集合中满足条件的元素，若元素满足条件，则返回该元素。否则返回null</li>
<li>sorted() : 自然升序。</li>
<li>sortedBy{} : 根据条件升序，即把不满足条件的放在前面，满足条件的放在后面</li>
<li>sortedDescending() : 自然降序。</li>
<li>sortedByDescending{} : 根据条件降序。和sortedBy{}相反</li>
<li>slice() : 过滤掉所有不满足执行下标的元素。</li>
<li>sum() : 计算出集合元素累加的结果。</li>
<li>sumBy{…} : 根据元素运算操作后的结果，然后根据这个结果计算出累加的值。</li>
<li>sumByDouble{…} : 和sumBy{}相似，不过sumBy{}是操作Int类型数据，而sumByDouble{}操作的是Double类型数据</li>
</ul>
<h6 id="T"><a href="#T" class="headerlink" title="T"></a>T</h6><ul>
<li>take(num) : 返回集合中前num个元素组成的集合</li>
<li>takeWhile{…} : 循环遍历集合，从第一个元素开始遍历集合，当第一个出现不满足条件元素的时候，退出遍历。然后把满足条件所有元素组成的集合返回。</li>
<li>takeLast(num) : 返回集合中后num个元素组成的集合</li>
<li>takeLastWhile{…} : 循环遍历集合，从最后一个元素开始遍历集合，当第一个出现不满足条件元素的时候，退出遍历。然后把满足条件所有元素组成的集合返回。</li>
</ul>
<h6 id="U"><a href="#U" class="headerlink" title="U"></a>U</h6><ul>
<li>unzip() : 和zip的作用相反。把一个类型为List<Pair>的集合拆分为两个集合</li>
</ul>
<h6 id="V"><a href="#V" class="headerlink" title="V"></a>V</h6><h6 id="W"><a href="#W" class="headerlink" title="W"></a>W</h6><h6 id="X"><a href="#X" class="headerlink" title="X"></a>X</h6><h6 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h6><h6 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h6><ul>
<li>zip() : 返回一个列表，该列表由两个集合中相同索引元素建立的元素对。这个列表长度为最短集合的长度</li>
</ul>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的六大基本原则</title>
    <url>/2021/06/25/oop-basic-principle/</url>
    <content><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>面向对象的六大原则：</p>
<ul>
<li>单一职责原则：SRP（Single-Resposibility Principle）</li>
<li>开放封闭原则：OCP（Open-Closed Principle）</li>
<li>里氏替换原则：LSP（Liskov-Substituition Principle）</li>
<li>依赖倒置原则：DIP（Dependecy-Inversion Principle）</li>
<li>接口分离原则：ISP（Interface-Segregation Principle）</li>
<li>迪米特原则：LoD（Law of Demete）</li>
</ul>
<span id="more"></span>

<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><ul>
<li><h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5></li>
</ul>
<p>一个类的功能要单一，不能包罗万象。一个类中应该是一组相关性很高的函数，数据的封装。</p>
<p>优点是降低类的复杂度，提高类的可读性，降低变更引起的风险。</p>
<ul>
<li><h5 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h5></li>
</ul>
<p>在扩展性上应该是开放的，而在更改性上是封闭的。</p>
<p>一个类的实现仅应因其错误而修改，当要对这个类增加新的元素时，不应对原有代码进行修改，而应对原代码进行拓展，以避免新引入的代码对原有系统产生影响，从而产生新的bug。</p>
<p>优点是提高系统的稳定性和可维护性。</p>
<ul>
<li><h5 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5></li>
</ul>
<p>所有引用基类的地方必须能透明的使用其子类的对象。</p>
<p>基类可以出现的地方，把基类替换成子类不会产生错误和异常，但是反过来就不行了，子类出现的地方把子类替换成父类就不一定不会出现问题了。</p>
<p>优点是代码共享，减少类创建的工作量，提高代码的重用性，提高代码的可扩展性，提高项目的开放性。</p>
<ul>
<li><h5 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h5></li>
</ul>
<p>通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p>
<p>优点是可扩展性好，耦合度低。</p>
<ul>
<li><h5 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h5></li>
</ul>
<p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来，即面向接口编程。提供接口，给其他模块使用。</p>
<p>类间的依赖关系应该建立在最小的接口上。建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。一个接口应该只实现一个功能，不应实现多个功能。</p>
<p>优点是降低耦合性，提升了代码的可读性，隐藏了实现细节。</p>
<ul>
<li><h5 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h5></li>
</ul>
<p>一个类应该对自己需要耦合或调用的类知道的最少，当一个类对另一个类进行调用时，只需要知道另外一个类的方法就行了，对里面的实现和结构都不需要了解。这样可以降低调用类与被调用类的耦合度，当被调用类的结构什么的发生改变时，只要方法接口不发生改变，对调用类就几乎没有任何影响。</p>
<p>优点是降低复杂度，降低耦合度，增加稳定性。</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Principle</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python实现人脸识别</title>
    <url>/2021/02/25/python-face-recognition/</url>
    <content><![CDATA[<h2 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h2><p>开发前安装和配置dlib和face_recognition</p>
<span id="more"></span>

<h3 id="安装Visual-Studio"><a href="#安装Visual-Studio" class="headerlink" title="安装Visual Studio"></a>安装Visual Studio</h3><ul>
<li>安装VS 2015 C++：下载地址：<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=48145%E3%80%82">https://www.microsoft.com/en-us/download/confirmation.aspx?id=48145。</a></li>
<li>安装Visual Studio：下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/%E3%80%82">https://visualstudio.microsoft.com/zh-hans/downloads/。</a> 安装过程中应该注意：在工作负载中选中“使用C++的桌面开发”，我这里还选中了“Visual Studio扩展开发”。</li>
</ul>
<h3 id="安装Boost-C-Libraries"><a href="#安装Boost-C-Libraries" class="headerlink" title="安装Boost C++ Libraries"></a>安装Boost C++ Libraries</h3><ul>
<li>下载地址：<a href="https://sourceforge.net/projects/boost/files%EF%BC%8C%E9%80%89%E6%8B%A9boost-binaries%EF%BC%8C%E6%89%BE%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E4%B8%8B%E8%BD%BDexe%E3%80%82%EF%BC%88%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E4%B8%8B%E5%88%B0%E6%9C%80%E5%90%8E%E5%B0%B1%E6%B2%A1%E8%B5%84%E6%BA%90%E4%BA%86%EF%BC%8C%E5%BE%88%E6%97%A0%E5%A5%88%EF%BC%89">https://sourceforge.net/projects/boost/files，选择boost-binaries，找到最新版本，下载exe。（官网下载下到最后就没资源了，很无奈）</a></li>
<li>运行exe文件，选择安装路径，进行安装。时间较慢，慢慢等待。</li>
<li>将360等安全软件关闭掉。</li>
<li>在菜单中，找到并打开“适用于VS 2017的x86_x64兼容工具命令提示”，输入命令：cd xx:\xx…\boost\boost_1_68_0（即进入boost安装目录下）。 再次输入：bootstrap.bat。 此时，会生成b2.exe、bjam.exe和project-config.jam文件。 ———-* 找到：project-config.jam，编辑： import option ; using msvc : 14.1 : “cl.exe的路径” option.set keep-going : false ; ———–*我在安装好之后，直接点击了b2.exe文件，然后他就开始编译了。 我也已经搞不清楚该怎么实现了。你可以都试试，目的是成功就行了。 ps：关于boost的编译，还没有搞清楚，好像不用编译也可以。</li>
</ul>
<h3 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h3><p>下载地址：<a href="https://cmake.org/download/%E3%80%82">https://cmake.org/download/。</a> 建议下载msi文件。可以自动配置环境变量。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>通过pip install dlib和pip install face_recognition进行最后的安装。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在python文件中import face_recognition检验是否安装成功。</p>
<h3 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h3><p>pip install opencv-python</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用OpenCV</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 调用人脸识别</span></span><br><span class="line"><span class="keyword">import</span> face_recognition <span class="keyword">as</span> fc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开摄像头，参数为调用第几个摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载样本图片，并了解如何识别它</span></span><br><span class="line">img = fc.load_image_file(<span class="string">&#x27;h.jpg&#x27;</span>)</span><br><span class="line">fc_encoding = fc.face_encodings(img)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">know_fcs = [fc_encoding]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一些变量</span></span><br><span class="line">fc_locations = []</span><br><span class="line">fc_encodings = []</span><br><span class="line">fc_names = []</span><br><span class="line">process_this_frame = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 获取每一帧视频</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调整视频大小为4分之1，便于更快的进行识别</span></span><br><span class="line">    small_frame = cv2.resize(frame, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.25</span>, fy=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将图像转换为RGB颜色</span></span><br><span class="line">    rgb_sframe = small_frame[:, :, ::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅处理每一帧视频节省时间</span></span><br><span class="line">    <span class="keyword">if</span> process_this_frame:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在当前视频帧中查找所有面部和面部编码</span></span><br><span class="line">        fc_locations = fc.face_locations(rgb_sframe)</span><br><span class="line">        fc_encodings = fc.face_encodings(rgb_sframe, fc_locations)</span><br><span class="line"></span><br><span class="line">        fc_names = []</span><br><span class="line">        <span class="keyword">for</span> encoding <span class="keyword">in</span> fc_encodings:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断面部是否与已知面部匹配</span></span><br><span class="line">            matches = fc.compare_faces(know_fcs, encoding)</span><br><span class="line">            name = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">in</span> matches:</span><br><span class="line">                first_index = matches.index(<span class="literal">True</span>)</span><br><span class="line">                name = <span class="string">&#x27;huge&#x27;</span></span><br><span class="line"></span><br><span class="line">            fc_names.append(name)</span><br><span class="line"></span><br><span class="line">    process_this_frame = <span class="keyword">not</span> process_this_frame</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示结果</span></span><br><span class="line">    <span class="keyword">for</span> (top, right, bottom, left), name <span class="keyword">in</span> <span class="built_in">zip</span>(fc_locations, fc_names):</span><br><span class="line">        top *= <span class="number">4</span></span><br><span class="line">        right *= <span class="number">4</span></span><br><span class="line">        bottom *= <span class="number">4</span></span><br><span class="line">        left *= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在脸上画上矩形区域</span></span><br><span class="line">        cv2.rectangle(frame, (left, top), (right, bottom), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在脸部下面绘制名字标签</span></span><br><span class="line">        cv2.rectangle(frame, (left, bottom - <span class="number">35</span>), (right, bottom), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), cv2.FILLED)</span><br><span class="line">        font = cv2.FONT_HERSHEY_DUPLEX</span><br><span class="line">        cv2.putText(frame, name, (left + <span class="number">6</span>, bottom - <span class="number">6</span>), font, <span class="number">1.0</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示结果图像</span></span><br><span class="line">        cv2.imshow(<span class="string">&#x27;Video&#x27;</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击键盘的‘q’以退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放摄像头的手柄</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer的127和128</title>
    <url>/2021/06/25/strange-integer/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java中有一个奇怪的判断，两个Integer类型的127和两个Integer类型的128进行对比判断，为什么它还不相等呢？！</p>
<span id="more"></span>

<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>首先需要了解基本数据类型，基本数据类型分为值类型和引用类型</p>
<h5 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h5><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">内存</th>
<th align="center">默认值</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">8位</td>
<td align="center">0</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16位</td>
<td align="center">0</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位</td>
<td align="center">0</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64位</td>
<td align="center">0L或0l</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32位</td>
<td align="center">0.0F或0.0f</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64位</td>
<td align="center">0.0D或0.0d</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16位</td>
<td align="center">\u0000</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">8位</td>
<td align="center">flase</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ul>
<li>数组：Array</li>
<li>类：Class</li>
<li>接口：Interface</li>
<li>枚举：Enum</li>
</ul>
<h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><ol>
<li>概念：<ul>
<li>值类型：变量名指向具体的值</li>
<li>引用类型：变量名指向数据对象的内存地址</li>
</ul>
</li>
<li>内存构建：<ul>
<li>值类型：变量在声明之后，Java就会立刻分配给它内存空间</li>
<li>引用类型：它以特殊的方式（类似C指针）指向对象实体，这类变量声明时不会分配内存，只是存储</li>
</ul>
</li>
<li>使用：<ul>
<li>值类型：使用时需要赋具体值，判断时用 ” &#x3D;&#x3D; “号</li>
<li>引用类型：使用时可以赋null，判断时使用 equals 方法</li>
</ul>
</li>
</ol>
<h5 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h5><p>定义：</p>
<ul>
<li>拆箱：将引用类型转换成值类型的过程</li>
<li>装箱：将值类型装换成引用类型的过程</li>
</ul>
<p>如何实现：</p>
<ul>
<li>装箱过程是通过调用包装器的valueOf方法实现的</li>
<li>拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）</li>
</ul>
<p>注意：</p>
<p>大量使用自动拆装箱会使性能降低，还会造成大量的内存消耗；在重载方法中，可能出现问题。</p>
<p>Byte、Short、Integer、Long四种包装类默认创建了数值为[-128,127]的相应类型的缓存数据，但是超出此范围仍会创建新的对象。</p>
<p>Character默认会创建[0,127]的响应类型的缓存数据。</p>
<p>两种浮点型没有实现常量池技术，在某个范围内的整型数值的个数是有限的，而浮点数却不是</p>
<table>
<thead>
<tr>
<th align="center">包装类</th>
<th align="center">常量池</th>
<th align="center">常量池范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Byte</td>
<td align="center">存在</td>
<td align="center">[-128,127]</td>
</tr>
<tr>
<td align="center">Short</td>
<td align="center">存在</td>
<td align="center">[-128,127]</td>
</tr>
<tr>
<td align="center">Integer</td>
<td align="center">存在</td>
<td align="center">[-128,127]</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">存在</td>
<td align="center">[-128,127]</td>
</tr>
<tr>
<td align="center">Character</td>
<td align="center">存在</td>
<td align="center">[0,127]</td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">不存在</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center">不存在</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>两个Integer类型的127进行<code>==</code>比较，结果为true</p>
<p>两个new Integer(127)进行<code>==</code>比较，结果为false，因为内存地址不同</p>
<p>两个Integer类型的128进行<code>==</code>比较，结果为false，因为内存地址不同</p>
<p>两个Integer类型的128进行<code>equals()</code>比较，结果为true，比较的是值</p>
]]></content>
      <categories>
        <category>-编程</category>
      </categories>
      <tags>
        <tag>Principle</tag>
      </tags>
  </entry>
</search>
